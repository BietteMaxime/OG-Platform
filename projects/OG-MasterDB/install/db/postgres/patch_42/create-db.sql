-- IMPORTANT:
--
-- This file was generated by concatenating the other .sql files together. It can be
-- used for testing, but the separate SQL sequences will be necessary if the Security Master
-- and Position Master need to be installed in different databases.
--
-- Please do not modify it - modify the originals and recreate this using 'ant create-db-sql'.


CREATE SEQUENCE hibernate_sequence START WITH 1 INCREMENT BY 1;

-- create-db-config.sql: Config Master

-- design has one document
--  config
-- unitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE cfg_config_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby/HSQL, not accepted by Postgresql

CREATE TABLE cfg_config (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name varchar(255) NOT NULL,
    config_type varchar(255) NOT NULL,
    config bytea NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT cfg_chk_config_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT cfg_chk_config_corr_order CHECK (corr_from_instant <= corr_to_instant),
    CONSTRAINT name_type_unique UNIQUE (name, config_type, ver_to_instant) -- TODO this is not right IGN-101
);
CREATE INDEX ix_cfg_config_oid ON cfg_config(oid);
CREATE INDEX ix_cfg_config_ver_from_instant ON cfg_config(ver_from_instant);
CREATE INDEX ix_cfg_config_ver_to_instant ON cfg_config(ver_to_instant);
CREATE INDEX ix_cfg_config_corr_from_instant ON cfg_config(corr_from_instant);
CREATE INDEX ix_cfg_config_corr_to_instant ON cfg_config(corr_to_instant);
CREATE INDEX ix_cfg_config_name ON cfg_config(name);
CREATE INDEX ix_cfg_config_nameu ON cfg_config(UPPER(name));
CREATE INDEX ix_cfg_config_config_type ON cfg_config(config_type);


-- create-db-refdata.sql

-- Holiday Master design has one document
--  holiday and associated dates
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE hol_holiday_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby/HSQL, not accepted by Postgresql

CREATE TABLE hol_holiday (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name varchar(255) NOT NULL,
    provider_scheme varchar(255),
    provider_value varchar(255),
    hol_type varchar(255) NOT NULL,
    region_scheme varchar(255),
    region_value varchar(255),
    exchange_scheme varchar(255),
    exchange_value varchar(255),
    currency_iso varchar(255),
    PRIMARY KEY (id),
    CONSTRAINT hol_chk_holiday_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT hol_chk_holiday_corr_order CHECK (corr_from_instant <= corr_to_instant)
);
CREATE INDEX ix_hol_holiday_oid ON hol_holiday(oid);
CREATE INDEX ix_hol_holiday_ver_from_instant ON hol_holiday(ver_from_instant);
CREATE INDEX ix_hol_holiday_ver_to_instant ON hol_holiday(ver_to_instant);
CREATE INDEX ix_hol_holiday_corr_from_instant ON hol_holiday(corr_from_instant);
CREATE INDEX ix_hol_holiday_corr_to_instant ON hol_holiday(corr_to_instant);
CREATE INDEX ix_hol_holiday_name ON hol_holiday(name);
CREATE INDEX ix_hol_holiday_nameu ON hol_holiday(UPPER(name));
CREATE INDEX ix_hol_holiday_provider_scheme ON hol_holiday(provider_scheme);
CREATE INDEX ix_hol_holiday_provider_value ON hol_holiday(provider_value);
CREATE INDEX ix_hol_holiday_holiday_type ON hol_holiday(hol_type);
CREATE INDEX ix_hol_holiday_region_scheme ON hol_holiday(region_scheme);
CREATE INDEX ix_hol_holiday_region_value ON hol_holiday(region_value);
CREATE INDEX ix_hol_holiday_exchange_scheme ON hol_holiday(exchange_scheme);
CREATE INDEX ix_hol_holiday_exchange_value ON hol_holiday(exchange_value);
CREATE INDEX ix_hol_holiday_currency_iso ON hol_holiday(currency_iso);

CREATE TABLE hol_date (
    holiday_id bigint NOT NULL,
    hol_date date NOT NULL,
    CONSTRAINT hol_fk_date2hol FOREIGN KEY (holiday_id) REFERENCES hol_holiday (id)
);
CREATE INDEX ix_hol_date_holiday_id ON hol_date(holiday_id);


-- Exchange Master design has one document
--  exchange and associated identifiers
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE exg_exchange_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
CREATE SEQUENCE exg_idkey_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby/HSQL, not accepted by Postgresql

CREATE TABLE exg_exchange (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name varchar(255) NOT NULL,
    time_zone varchar(255),
    detail bytea NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT exg_chk_exchange_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT exg_chk_exchange_corr_order CHECK (corr_from_instant <= corr_to_instant)
);
CREATE INDEX ix_exg_exchange_oid ON exg_exchange(oid);
CREATE INDEX ix_exg_exchange_ver_from_instant ON exg_exchange(ver_from_instant);
CREATE INDEX ix_exg_exchange_ver_to_instant ON exg_exchange(ver_to_instant);
CREATE INDEX ix_exg_exchange_corr_from_instant ON exg_exchange(corr_from_instant);
CREATE INDEX ix_exg_exchange_corr_to_instant ON exg_exchange(corr_to_instant);
CREATE INDEX ix_exg_exchange_name ON exg_exchange(name);
CREATE INDEX ix_exg_exchange_nameu ON exg_exchange(UPPER(name));

CREATE TABLE exg_idkey (
    id bigint NOT NULL,
    key_scheme varchar(255) NOT NULL,
    key_value varchar(255) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT exg_chk_idkey UNIQUE (key_scheme, key_value)
);

CREATE TABLE exg_exchange2idkey (
    exchange_id bigint NOT NULL,
    idkey_id bigint NOT NULL,
    PRIMARY KEY (exchange_id, idkey_id),
    CONSTRAINT exg_fk_exgidkey2exg FOREIGN KEY (exchange_id) REFERENCES exg_exchange (id),
    CONSTRAINT exg_fk_exgidkey2idkey FOREIGN KEY (idkey_id) REFERENCES exg_idkey (id)
);
CREATE INDEX ix_exg_exg2idkey_idkey ON exg_exchange2idkey(idkey_id);
-- exg_exchange2idkey is fully dependent of exg_exchange


-- create-db-engine.sql: Config Master

create table eng_functioncosts (
    configuration varchar(255) NOT NULL,
    function varchar(255) NOT NULL,
    version_instant timestamp without time zone NOT NULL,
    invocation_cost decimal(31,8) NOT NULL,
    data_input_cost decimal(31,8) NOT NULL,
    data_output_cost decimal(31,8) NOT NULL,
    PRIMARY KEY (configuration, function, version_instant)
);


-- create-db-security.sql: Security Master

-- design has one document
--  security and associated identity key
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE sec_security_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
CREATE SEQUENCE sec_idkey_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby/HSQL, not accepted by Postgresql

CREATE TABLE sec_security (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name varchar(255) NOT NULL,
    sec_type varchar(255) NOT NULL,
    detail_type char NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_sec2sec FOREIGN KEY (oid) REFERENCES sec_security (id),
    CONSTRAINT sec_chk_sec_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT sec_chk_sec_corr_order CHECK (corr_from_instant <= corr_to_instant),
    CONSTRAINT sec_chk_detail_type CHECK (detail_type IN ('D', 'M', 'R'))
);
CREATE INDEX ix_sec_security_oid ON sec_security(oid);
CREATE INDEX ix_sec_security_ver_from_instant ON sec_security(ver_from_instant);
CREATE INDEX ix_sec_security_ver_to_instant ON sec_security(ver_to_instant);
CREATE INDEX ix_sec_security_corr_from_instant ON sec_security(corr_from_instant);
CREATE INDEX ix_sec_security_corr_to_instant ON sec_security(corr_to_instant);
CREATE INDEX ix_sec_security_name ON sec_security(name);
CREATE INDEX ix_sec_security_nameu ON sec_security(UPPER(name));
CREATE INDEX ix_sec_security_sec_type ON sec_security(sec_type);
CREATE INDEX ix_sec_security_sec_typeu ON sec_security(UPPER(sec_type));

CREATE TABLE sec_idkey (
    id bigint NOT NULL,
    key_scheme varchar(255) NOT NULL,
    key_value varchar(255) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_chk_idkey UNIQUE (key_scheme, key_value)
);

CREATE TABLE sec_security2idkey (
    security_id bigint NOT NULL,
    idkey_id bigint NOT NULL,
    PRIMARY KEY (security_id, idkey_id),
    CONSTRAINT sec_fk_secidkey2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_secidkey2idkey FOREIGN KEY (idkey_id) REFERENCES sec_idkey (id)
);
CREATE INDEX ix_sec_sec2idkey_idkey ON sec_security2idkey(idkey_id);
-- sec_security_idkey is fully dependent of sec_security

-- Hibernate controlled tables
CREATE TABLE sec_currency (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_commodityfuturetype (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_bondfuturetype (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_cashrate (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_unit (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_exchange (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    description varchar(255),
    PRIMARY KEY (id)
);

CREATE TABLE sec_gics (
    id bigint NOT NULL,
    name varchar(8) NOT NULL UNIQUE,
    description varchar(255),
    PRIMARY KEY (id)
);

CREATE TABLE sec_equity (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    shortName varchar(255),
    exchange_id bigint NOT NULL,
    companyName varchar(255) NOT NULL,
    currency_id bigint NOT NULL,
    gicscode_id bigint,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_equity2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_equity2currency FOREIGN KEY (currency_id) REFERENCES sec_currency(id),
    CONSTRAINT sec_fk_equity2exchange FOREIGN KEY (exchange_id) REFERENCES sec_exchange(id),
    CONSTRAINT sec_fk_equity2gics FOREIGN KEY (gicscode_id) REFERENCES sec_gics(id)
);
CREATE INDEX ix_sec_equity_security_id ON sec_equity(security_id);

CREATE TABLE sec_equityindexoption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    option_type varchar(32) NOT NULL,
    strike double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    currency_id bigint NOT NULL,
    exchange_id bigint,
    pointValue double precision,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_equityindexoption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_equityindexoption2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_equityindexoption2exchange FOREIGN KEY (exchange_id) REFERENCES sec_exchange (id)
);

CREATE TABLE sec_equityoption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    option_type varchar(32) NOT NULL,
    strike double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    currency_id bigint NOT NULL,
    exchange_id bigint,
    pointValue double precision,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_equityoption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_equityoption2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_equityoption2exchange FOREIGN KEY (exchange_id) REFERENCES sec_exchange (id)
);
CREATE INDEX ix_sec_equityoption_security_id ON sec_equityoption(security_id);

CREATE TABLE sec_equitybarrieroption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    option_type varchar(32) NOT NULL,
    strike double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    currency_id bigint NOT NULL,
    exchange_id bigint,
    pointValue double precision,
	barrier_type varchar(32) NOT NULL,
    barrier_direction varchar(32) NOT NULL,
    barrier_level double precision NOT NULL,
    monitoring_type varchar(32) NOT NULL,
    sampling_frequency varchar(32),
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_equitybarrieroption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_equitybarrieroption2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_equitybarrieroption2exchange FOREIGN KEY (exchange_id) REFERENCES sec_exchange (id)
);
CREATE INDEX ix_sec_equitybarrieroption_security_id ON sec_equitybarrieroption(security_id);


CREATE TABLE sec_fxoption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    put_amount double precision NOT NULL,
    call_amount double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    put_currency_id bigint NOT NULL,
    call_currency_id bigint NOT NULL,
    settlement_date timestamp without time zone NOT NULL,
    settlement_zone varchar(50) NOT NULL,
    is_long boolean NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_fxoption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_fxoption2putcurrency FOREIGN KEY (put_currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_fxoption2callcurrency FOREIGN KEY (call_currency_id) REFERENCES sec_currency (id)
);

CREATE TABLE sec_nondeliverablefxoption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    put_amount double precision NOT NULL,
    call_amount double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    put_currency_id bigint NOT NULL,
    call_currency_id bigint NOT NULL,
    settlement_date timestamp without time zone NOT NULL,
    settlement_zone varchar(50) NOT NULL,
    is_long boolean NOT NULL,
	is_delivery_in_call_currency boolean NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_nondeliverablefxoption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_nondeliverablefxoption2putcurrency FOREIGN KEY (put_currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_nondeliverablefxoption2callcurrency FOREIGN KEY (call_currency_id) REFERENCES sec_currency (id)
);
CREATE INDEX ix_sec_nondeliverablefxoption_security_id ON sec_nondeliverablefxoption(security_id);

CREATE TABLE sec_swaption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    cash_settled boolean NOT NULL,
    is_long boolean NOT NULL,
    is_payer boolean NOT NULL,
    currency_id bigint NOT NULL,
    option_exercise_type VARCHAR(32),
    settlement_date TIMESTAMP,
    settlement_zone VARCHAR(50),
    notional double precision,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_swaption2currency FOREIGN KEY (currency_id) REFERENCES sec_currency(id),
    CONSTRAINT sec_fk_swaption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id)
);

CREATE TABLE sec_irfutureoption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    option_type varchar(32) NOT NULL,
    strike double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    currency_id bigint NOT NULL,
    exchange_id bigint NOT NULL,
    margined boolean NOT NULL,
    pointValue double precision NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_irfutureoption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_irfutureoption2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_irfutureoption2exchange FOREIGN KEY (exchange_id) REFERENCES sec_exchange (id)
);

CREATE TABLE sec_equity_index_dividend_futureoption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    option_exercise_type varchar(32) NOT NULL,
    option_type varchar(32) NOT NULL,
    strike double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    currency_id bigint NOT NULL,
    exchange_id bigint NOT NULL,
    margined boolean NOT NULL,
    pointValue double precision NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_equity_index_dividend_futureoption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_equity_index_dividend_futureoption2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_equity_index_dividend_futureoption2exchange FOREIGN KEY (exchange_id) REFERENCES sec_exchange (id)
);
CREATE INDEX ix_sec_equity_index_dividend_futureoption_security_id ON sec_equity_index_dividend_futureoption(security_id);

CREATE TABLE sec_fxbarrieroption (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    put_amount double precision NOT NULL,
    call_amount double precision NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    put_currency_id bigint NOT NULL,
    call_currency_id bigint NOT NULL,
    settlement_date timestamp without time zone NOT NULL,
    settlement_zone varchar(50) NOT NULL,
    barrier_type varchar(32) NOT NULL,
    barrier_direction varchar(32) NOT NULL,
    barrier_level double precision NOT NULL,
    monitoring_type varchar(32) NOT NULL,
    sampling_frequency varchar(32),
    is_long boolean NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_fxbarrieroption2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_fxbarrieroption2putcurrency FOREIGN KEY (put_currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_fxbarrieroption2callcurrency FOREIGN KEY (call_currency_id) REFERENCES sec_currency (id)
);

CREATE TABLE sec_frequency (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_daycount (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_businessdayconvention (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
);

CREATE TABLE sec_issuertype (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
 );

CREATE TABLE sec_market (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
 );

CREATE TABLE sec_yieldconvention (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
 );

CREATE TABLE sec_guaranteetype (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
 );

CREATE TABLE sec_coupontype (
    id bigint NOT NULL,
    name varchar(255) NOT NULL UNIQUE,
    PRIMARY KEY (id)
 );

CREATE TABLE sec_bond (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    bond_type varchar(32) NOT NULL,
    issuername varchar(255) NOT NULL,
    issuertype_id bigint NOT NULL,
    issuerdomicile varchar(255) NOT NULL,
    market_id bigint NOT NULL,
    currency_id bigint NOT NULL,
    yieldconvention_id bigint NOT NULL,
    guaranteetype_id bigint,
    maturity_date timestamp without time zone NOT NULL,
    maturity_zone varchar(50) NOT NULL,
    maturity_accuracy smallint NOT NULL,
    coupontype_id bigint NOT NULL,
    couponrate double precision NOT NULL,
    couponfrequency_id bigint NOT NULL,
    daycountconvention_id bigint NOT NULL,
    businessdayconvention_id bigint,
    announcement_date timestamp without time zone,
    announcement_zone varchar(50),
    interestaccrual_date timestamp without time zone NOT NULL,
    interestaccrual_zone varchar(50) NOT NULL,
    settlement_date timestamp without time zone NOT NULL,
    settlement_zone varchar(50) NOT NULL,
    firstcoupon_date timestamp without time zone NOT NULL,
    firstcoupon_zone varchar(50) NOT NULL,
    issuanceprice double precision NOT NULL,
    totalamountissued double precision NOT NULL,
    minimumamount double precision NOT NULL,
    minimumincrement double precision NOT NULL,
    paramount double precision NOT NULL,
    redemptionvalue double precision NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_bond2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_bond2issuertype FOREIGN KEY (issuertype_id) REFERENCES sec_issuertype (id),
    CONSTRAINT sec_fk_bond2market FOREIGN KEY (market_id) REFERENCES sec_market (id),
    CONSTRAINT sec_fk_bond2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_bond2yieldconvention FOREIGN KEY (yieldconvention_id) REFERENCES sec_yieldconvention (id),
    CONSTRAINT sec_fk_bond2guaranteetype FOREIGN KEY (guaranteetype_id) REFERENCES sec_guaranteetype (id),
    CONSTRAINT sec_fk_bond2coupontype FOREIGN KEY (coupontype_id) REFERENCES sec_coupontype (id),
    CONSTRAINT sec_fk_bond2frequency FOREIGN KEY (couponfrequency_id) REFERENCES sec_frequency (id),
    CONSTRAINT sec_fk_bond2daycount FOREIGN KEY (daycountconvention_id) REFERENCES sec_daycount (id),
    CONSTRAINT sec_fk_bond2businessdayconvention FOREIGN KEY (businessdayconvention_id) REFERENCES sec_businessdayconvention (id)
);
CREATE INDEX ix_sec_bond_security_id ON sec_bond(security_id);

CREATE TABLE sec_future (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    future_type varchar(32) NOT NULL,
    expiry_date timestamp without time zone NOT NULL,
    expiry_zone varchar(50) NOT NULL,
    expiry_accuracy smallint NOT NULL,
    tradingexchange_id bigint NOT NULL,
    settlementexchange_id bigint NOT NULL,
    currency1_id bigint,
    currency2_id bigint,
    currency3_id bigint,
    bondtype_id bigint,
    commoditytype_id bigint,
    unitname_id bigint,
    unitnumber double precision,
    unit_amount double precision,
    underlying_scheme varchar(255),
    underlying_identifier varchar(255), 
    bondFutureFirstDeliveryDate timestamp without time zone,
    bondFutureFirstDeliveryDate_zone varchar(50),
    bondFutureLastDeliveryDate timestamp without time zone,
    bondFutureLastDeliveryDate_zone varchar(50),
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_future2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_future2exchange1 FOREIGN KEY (tradingexchange_id) REFERENCES sec_exchange (id),
    CONSTRAINT sec_fk_future2exchange2 FOREIGN KEY (settlementexchange_id) REFERENCES sec_exchange (id),
    CONSTRAINT sec_fk_future2currency1 FOREIGN KEY (currency1_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_future2currency2 FOREIGN KEY (currency2_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_future2currency3 FOREIGN KEY (currency3_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_future2bondfuturetype FOREIGN KEY (bondtype_id) REFERENCES sec_bondfuturetype (id),
    CONSTRAINT sec_fk_future2commodityfuturetype FOREIGN KEY (commoditytype_id) REFERENCES sec_commodityfuturetype (id),
    CONSTRAINT sec_fk_future2unit FOREIGN KEY (unitname_id) REFERENCES sec_unit (id)
);
CREATE INDEX ix_sec_future_security_id ON sec_future(security_id);

CREATE TABLE sec_futurebundle (
    id bigint NOT NULL,
    future_id bigint NOT NULL,
    startDate timestamp without time zone,
    endDate timestamp without time zone,
    conversionFactor double precision NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_futurebundle2future FOREIGN KEY (future_id) REFERENCES sec_future (id)
);

CREATE TABLE sec_futurebundleidentifier (
    bundle_id bigint NOT NULL,
    scheme varchar(255) NOT NULL,
    identifier varchar(255) NOT NULL,
    PRIMARY KEY (bundle_id, scheme, identifier),
    CONSTRAINT sec_fk_futurebundleidentifier2futurebundle FOREIGN KEY (bundle_id) REFERENCES sec_futurebundle (id)
);

CREATE TABLE sec_cash (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    currency_id bigint NOT NULL,
    region_scheme varchar(255) NOT NULL,
    region_identifier varchar(255) NOT NULL,
    maturity_date timestamp without time zone NOT NULL,
    maturity_zone varchar(50) NOT NULL,
    rate double precision NOT NULL,
    amount double precision NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_cash2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_cash2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id)
);

CREATE TABLE sec_fra (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    currency_id bigint NOT NULL,
    region_scheme varchar(255) NOT NULL,
    region_identifier varchar(255) NOT NULL,
    start_date timestamp without time zone NOT NULL,
    start_zone varchar(50) NOT NULL,
    end_date timestamp without time zone NOT NULL,
    end_zone varchar(50) NOT NULL,
    rate double precision NOT NULL,
    amount double precision NOT NULL,
    underlying_scheme varchar(255) NOT NULL,
    underlying_identifier varchar(255) NOT NULL,
    fixing_date timestamp without time zone NOT NULL,
    fixing_zone varchar(50) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_fra2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_fra2currency FOREIGN KEY (currency_id) REFERENCES sec_currency (id)
);

CREATE TABLE sec_swap (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    swaptype varchar(32) NOT NULL,
    trade_date timestamp without time zone NOT NULL,
    trade_zone varchar(50) NOT NULL,
    effective_date timestamp without time zone NOT NULL,
    effective_zone varchar(50) NOT NULL,
    maturity_date timestamp without time zone NOT NULL,
    maturity_zone varchar(50) NOT NULL,
    forwardstart_date timestamp without time zone,
    forwardstart_zone varchar(50),
    counterparty varchar(255) NOT NULL,
    pay_legtype varchar(32) NOT NULL,
    pay_daycount_id bigint NOT NULL,
    pay_frequency_id bigint NOT NULL,
    pay_regionscheme varchar(255) NOT NULL,
    pay_regionid varchar(255) NOT NULL,
    pay_businessdayconvention_id bigint NOT NULL,
    pay_notionaltype varchar(32) NOT NULL,
    pay_notionalcurrency_id bigint,
    pay_notionalamount double precision,
    pay_notionalscheme varchar(255),
    pay_notionalid varchar(255),
    pay_rate double precision,
    pay_iseom boolean NOT NULL,
    pay_spread double precision,
    pay_rateidentifierscheme varchar(255),
    pay_rateidentifierid varchar(255),
    pay_floating_rate_type varchar(32),
    pay_settlement_days INTEGER,
    pay_gearing DOUBLE precision,
    pay_offset_fixing_id bigint,
    receive_legtype varchar(32) NOT NULL,
    receive_daycount_id bigint NOT NULL,
    receive_frequency_id bigint NOT NULL,
    receive_regionscheme varchar(255) NOT NULL,
    receive_regionid varchar(255) NOT NULL,
    receive_businessdayconvention_id bigint NOT NULL,
    receive_notionaltype varchar(32) NOT NULL,
    receive_notionalcurrency_id bigint,
    receive_notionalamount double precision,
    receive_notionalscheme varchar(255),
    receive_notionalid varchar(255),
    receive_rate double precision,
    receive_iseom boolean NOT NULL, 
    receive_spread double precision,
    receive_rateidentifierscheme varchar(255),
    receive_rateidentifierid varchar(255),
    receive_floating_rate_type varchar(32),
    receive_settlement_days INTEGER,
    receive_gearing DOUBLE precision,
    receive_offset_fixing_id bigint,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_swap2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_payfreq2frequency FOREIGN KEY (pay_frequency_id) REFERENCES sec_frequency (id),
    CONSTRAINT sec_fk_receivefreq2frequency FOREIGN KEY (receive_frequency_id) REFERENCES sec_frequency (id),
    CONSTRAINT sec_fk_payoffset2frequency FOREIGN KEY (pay_offset_fixing_id) REFERENCES sec_frequency (id),
    CONSTRAINT sec_fk_recvoffset2frequency FOREIGN KEY (receive_offset_fixing_id) REFERENCES sec_frequency (id)
);
CREATE INDEX ix_sec_swap_security_id ON sec_swap(security_id);

CREATE TABLE sec_raw (
    security_id bigint NOT NULL,
    raw_data bytea NOT NULL,
    CONSTRAINT sec_fk_raw2sec FOREIGN KEY (security_id) REFERENCES sec_security (id)
);

CREATE TABLE sec_fx (
    id bigint NOT NULL,
    security_id bigint NOT NULL,
    pay_currency_id bigint NOT NULL,
    receive_currency_id bigint NOT NULL,
    region_scheme varchar(255) NOT NULL,
    region_identifier varchar(255) NOT NULL,
    pay_amount double precision NOT NULL,
    receive_amount double precision NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT sec_fk_fx2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
    CONSTRAINT sec_fk_fxpay2currency FOREIGN KEY (pay_currency_id) REFERENCES sec_currency (id),
    CONSTRAINT sec_fk_fxreceive2currency FOREIGN KEY (receive_currency_id) REFERENCES sec_currency (id)
);

CREATE TABLE sec_fxforward (
  id bigint NOT NULL,
  security_id bigint NOT NULL,
  region_scheme varchar(255) NOT NULL,
  region_identifier varchar(255) NOT NULL,
  underlying_scheme varchar(255) NOT NULL,
  underlying_identifier varchar(255) NOT NULL,
  forward_date timestamp without time zone NOT NULL,
  forward_zone varchar(50) NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT sec_fk_fxforward2sec FOREIGN KEY (security_id) REFERENCES sec_security (id)
);
CREATE INDEX ix_sec_fxforward_security_id ON sec_fxforward(security_id);

CREATE TABLE sec_nondeliverablefxforward (
  id bigint NOT NULL,
  security_id bigint NOT NULL,
  region_scheme varchar(255) NOT NULL,
  region_identifier varchar(255) NOT NULL,
  underlying_scheme varchar(255) NOT NULL,
  underlying_identifier varchar(255) NOT NULL,
  forward_date timestamp without time zone NOT NULL,
  forward_zone varchar(50) NOT NULL,
  is_delivery_in_receive_currency boolean NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT sec_fk_nondeliverablefxforward2sec FOREIGN KEY (security_id) REFERENCES sec_security (id)
);
CREATE INDEX ix_sec_nondeliverablefxforward_security_id ON sec_nondeliverablefxforward(security_id);

CREATE TABLE sec_capfloor (
  id bigint NOT NULL,
  security_id bigint NOT NULL,
  currency_id bigint NOT NULL,
  daycountconvention_id bigint NOT NULL,
  frequency_id bigint NOT NULL,
  is_cap boolean NOT NULL,
  is_ibor boolean NOT NULL,
  is_payer boolean NOT NULL,
  maturity_date timestamp without time zone NOT NULL,
  maturity_zone varchar(50) NOT NULL,
  notional double precision NOT NULL,
  start_date timestamp without time zone NOT NULL,
  start_zone varchar(50) NOT NULL,
  strike double precision NOT NULL,
  underlying_scheme varchar(255) NOT NULL,
  underlying_identifier varchar(255) NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT sec_fk_capfloor2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
  CONSTRAINT sec_fk_capfloor2currency FOREIGN KEY (currency_id) REFERENCES sec_currency(id),
  CONSTRAINT sec_fk_capfloor2daycount FOREIGN KEY (daycountconvention_id) REFERENCES sec_daycount (id),
  CONSTRAINT sec_fk_capfloor2frequency FOREIGN KEY (frequency_id) REFERENCES sec_frequency (id)
);

CREATE TABLE  sec_capfloorcmsspread (
  id bigint NOT NULL,
  security_id bigint NOT NULL,
  currency_id bigint NOT NULL,
  daycountconvention_id bigint NOT NULL,
  frequency_id bigint NOT NULL,
  is_cap boolean NOT NULL,
  is_payer boolean NOT NULL,
  long_scheme varchar(255) NOT NULL,
  long_identifier varchar(255) NOT NULL,
  maturity_date timestamp without time zone NOT NULL,
  maturity_zone varchar(50) NOT NULL,
  notional double precision NOT NULL,
  short_scheme varchar(255) NOT NULL,
  short_identifier varchar(255) NOT NULL,
  start_date timestamp without time zone NOT NULL,
  start_zone varchar(50) NOT NULL,
  strike double precision NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT sec_fk_capfloorcmsspread2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
  CONSTRAINT sec_fk_capfloorcmsspread2currency FOREIGN KEY (currency_id) REFERENCES sec_currency(id),
  CONSTRAINT sec_fk_capfloorcmsspread2daycount FOREIGN KEY (daycountconvention_id) REFERENCES sec_daycount (id),
  CONSTRAINT sec_fk_capfloorcmsspread2frequency FOREIGN KEY (frequency_id) REFERENCES sec_frequency (id)
);

CREATE TABLE  sec_equity_variance_swap (
  id bigint NOT NULL,
  security_id bigint NOT NULL,
  annualization_factor double precision NOT NULL,
  currency_id bigint NOT NULL,
  first_observation_date timestamp without time zone NOT NULL,
  first_observation_zone varchar(50) NOT NULL,
  last_observation_date timestamp without time zone NOT NULL,
  last_observation_zone varchar(50) NOT NULL,
  notional double precision NOT NULL,
  observation_frequency_id bigint NOT NULL,
  parameterised_as_variance boolean NOT NULL,
  region_scheme varchar(255) NOT NULL,
  region_id varchar(255) NOT NULL,
  settlement_date timestamp without time zone NOT NULL,
  settlement_zone varchar(50) NOT NULL,
  spot_scheme varchar(255) NOT NULL,
  spot_id varchar(255) NOT NULL,
  strike double precision NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT sec_fk_equityvarianceswap2sec FOREIGN KEY (security_id) REFERENCES sec_security (id),
  CONSTRAINT sec_fk_equityvarianceswap2currency FOREIGN KEY (currency_id) REFERENCES sec_currency(id),
  CONSTRAINT sec_fk_equityvarianceswap2frequency FOREIGN KEY (observation_frequency_id) REFERENCES sec_frequency (id)
);

CREATE SEQUENCE sec_security_attr_seq
    start with 1000 increment by 1 no cycle;

CREATE TABLE sec_security_attribute (
    id bigint not null,
    security_id bigint not null,
    security_oid bigint not null,
    key varchar(255) not null,
    value varchar(255) not null,
    primary key (id),
    constraint sec_fk_securityattr2security foreign key (security_id) references sec_security (id),
    constraint sec_chk_uq_security_attribute unique (security_id, key, value)
);
-- security_oid is an optimization
-- sec_security_attribute is fully dependent of sec_security
CREATE INDEX ix_sec_security_attr_security_oid ON sec_security_attribute(security_oid);
CREATE INDEX ix_sec_security_attr_key ON sec_security_attribute(key);
-- create-db-portfolio.sql: Portfolio Master

-- design has one document
--  portfolio, tree of nodes (nested set model) and position ids
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE prt_master_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby, not accepted by Postgresql

CREATE TABLE prt_portfolio (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name varchar(255) NOT NULL,
    visibility smallint NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT prt_fk_port2port FOREIGN KEY (oid) REFERENCES prt_portfolio (id),
    CONSTRAINT prt_chk_port_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT prt_chk_port_corr_order CHECK (corr_from_instant <= corr_to_instant)
);
CREATE INDEX ix_prt_portfolio_oid ON prt_portfolio(oid);
CREATE INDEX ix_prt_portfolio_ver_from_instant ON prt_portfolio(ver_from_instant);
CREATE INDEX ix_prt_portfolio_ver_to_instant ON prt_portfolio(ver_to_instant);
CREATE INDEX ix_prt_portfolio_corr_from_instant ON prt_portfolio(corr_from_instant);
CREATE INDEX ix_prt_portfolio_corr_to_instant ON prt_portfolio(corr_to_instant);
CREATE INDEX ix_prt_portfolio_name ON prt_portfolio(name);
CREATE INDEX ix_prt_portfolio_nameu ON prt_portfolio(UPPER(name));
CREATE INDEX ix_prt_portfolio_visibility ON prt_portfolio(visibility);

CREATE TABLE prt_node (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    portfolio_id bigint NOT NULL,
    portfolio_oid bigint NOT NULL,
    parent_node_id bigint,
    parent_node_oid bigint,
    depth int,
    tree_left bigint NOT NULL,
    tree_right bigint NOT NULL,
    name varchar(255),
    PRIMARY KEY (id),
    CONSTRAINT prt_fk_node2node FOREIGN KEY (oid) REFERENCES prt_node (id),
    CONSTRAINT prt_fk_node2portfolio FOREIGN KEY (portfolio_id) REFERENCES prt_portfolio (id),
    CONSTRAINT prt_fk_node2parentnode FOREIGN KEY (parent_node_id) REFERENCES prt_node (id)
);
-- prt_node is fully dependent of prt_portfolio
-- portfolio_oid is an optimization (can be derived via portfolio_id)
-- parent_node_id is an optimization (tree_left/tree_right hold all the tree structure)
-- depth is an optimization (tree_left/tree_right hold all the tree structure)
CREATE INDEX ix_prt_node_oid ON prt_node(oid);
CREATE INDEX ix_prt_node_portfolio_id ON prt_node(portfolio_id);
CREATE INDEX ix_prt_node_portfolio_oid ON prt_node(portfolio_oid);
CREATE INDEX ix_prt_node_parent_node_id ON prt_node(parent_node_id);
CREATE INDEX ix_prt_node_parent_node_oid ON prt_node(parent_node_oid);
CREATE INDEX ix_prt_node_depth ON prt_node(depth);

CREATE TABLE prt_position (
    node_id bigint NOT NULL,
    key_scheme varchar(255) NOT NULL,
    key_value varchar(255) NOT NULL,
    CONSTRAINT prt_fk_pos2node FOREIGN KEY (node_id) REFERENCES prt_node (id)
);
-- prt_position is fully dependent of prt_portfolio
CREATE INDEX ix_prt_position_node_id ON prt_position(node_id);

CREATE SEQUENCE prt_portfolio_attr_seq
    start with 1000 increment by 1 no cycle;

CREATE TABLE prt_portfolio_attribute (
    id bigint not null,
    portfolio_id bigint not null,
    portfolio_oid bigint not null,
    key varchar(255) not null,
    value varchar(255) not null,
    primary key (id),
    constraint prt_fk_prtattr2portfolio foreign key (portfolio_id) references prt_portfolio (id),
    constraint prt_chk_uq_prt_attribute unique (portfolio_id, key, value)
);
-- portfolio_oid is an optimization
-- prt_portfolio_attribute is fully dependent of prt_portfolio
CREATE INDEX ix_prt_attr_portfolio_oid ON prt_portfolio_attribute(portfolio_oid);
CREATE INDEX ix_prt_attr_key ON prt_portfolio_attribute(key);

-- create-db-position.sql: Position Master

-- design has one document
--  position, trades and associated security ids
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE pos_master_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
CREATE SEQUENCE pos_idkey_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby, not accepted by Postgresql

CREATE TABLE pos_position (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    provider_scheme varchar(255),
    provider_value varchar(255),
    quantity decimal(31,8) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT pos_fk_posi2posi FOREIGN KEY (oid) REFERENCES pos_position (id),
    CONSTRAINT pos_chk_posi_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT pos_chk_posi_corr_order CHECK (corr_from_instant <= corr_to_instant)
);
CREATE INDEX ix_pos_position_oid ON pos_position(oid);
CREATE INDEX ix_pos_position_ver_from_instant ON pos_position(ver_from_instant);
CREATE INDEX ix_pos_position_ver_to_instant ON pos_position(ver_to_instant);
CREATE INDEX ix_pos_position_corr_from_instant ON pos_position(corr_from_instant);
CREATE INDEX ix_pos_position_corr_to_instant ON pos_position(corr_to_instant);
CREATE INDEX ix_pos_position_quantity ON pos_position(quantity);

CREATE TABLE pos_trade (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    position_id bigint NOT NULL,
    position_oid bigint NOT NULL,
    quantity decimal(31,8) NOT NULL,
    trade_date date NOT NULL,
    trade_time time null,
    zone_offset int null,
    cparty_scheme varchar(255) NOT NULL,
    cparty_value varchar(255) NOT NULL,
    provider_scheme varchar(255),
    provider_value varchar(255),
    premium_value double precision,
    premium_currency varchar(255),
    premium_date date,
    premium_time time,
    premium_zone_offset int,
    PRIMARY KEY (id),
    CONSTRAINT pos_fk_trade2position FOREIGN KEY (position_id) REFERENCES pos_position (id),
    CONSTRAINT pos_fk_tradei2tradei FOREIGN KEY (oid) REFERENCES pos_trade(id)
);
-- position_oid is an optimization
-- pos_trade is fully dependent of pos_position
CREATE INDEX ix_pos_trade_oid ON pos_trade(oid);
CREATE INDEX ix_pos_trade_position_id ON pos_trade(position_id);
CREATE INDEX ix_pos_trade_position_oid ON pos_trade(position_oid);

CREATE SEQUENCE pos_trade_attr_seq
    start with 1000 increment by 1 no cycle;

CREATE TABLE pos_trade_attribute (
    id bigint NOT NULL,
    trade_id bigint NOT NULL,
    trade_oid bigint NOT NULL,
    key varchar(255) NOT NULL,
    value varchar(255) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT pos_fk_tradeattr2trade FOREIGN KEY (trade_id) REFERENCES pos_trade (id),
    CONSTRAINT pos_chk_uq_trade_attribute UNIQUE (trade_id, key, value)
);
-- trade_oid is an optimization
-- pos_trade_attribute is fully dependent of pos_trade
CREATE INDEX ix_pos_trade_attr_trade_oid ON pos_trade_attribute(trade_oid);
CREATE INDEX ix_pos_trade_attr_key ON pos_trade_attribute(key);

CREATE TABLE pos_attribute (
    id bigint NOT NULL,
    position_id bigint NOT NULL,
    position_oid bigint NOT NULL,
    key varchar(255) NOT NULL,
    value varchar(255) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT pos_fk_posattr2pos FOREIGN KEY (position_id) REFERENCES pos_position (id),
    CONSTRAINT pos_chk_uq_pos_attribute UNIQUE (position_id, key, value)
);
-- position_oid is an optimization
-- pos_attribute is fully dependent of pos_position
CREATE INDEX ix_pos_attr_position_oid ON pos_attribute(position_oid);
CREATE INDEX ix_pos_attr_key ON pos_attribute(key);

CREATE TABLE pos_idkey (
    id bigint NOT NULL,
    key_scheme varchar(255) NOT NULL,
    key_value varchar(255) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT pos_chk_idkey UNIQUE (key_scheme, key_value)
);

CREATE TABLE pos_position2idkey (
    position_id bigint NOT NULL,
    idkey_id bigint NOT NULL,
    PRIMARY KEY (position_id, idkey_id),
    CONSTRAINT pos_fk_posidkey2pos FOREIGN KEY (position_id) REFERENCES pos_position (id),
    CONSTRAINT pos_fk_posidkey2idkey FOREIGN KEY (idkey_id) REFERENCES pos_idkey (id)
);
CREATE INDEX ix_pos_pos2idkey_idkey ON pos_position2idkey(idkey_id);

CREATE TABLE pos_trade2idkey (
    trade_id bigint NOT NULL,
    idkey_id bigint NOT NULL,
    PRIMARY KEY (trade_id, idkey_id),
    CONSTRAINT pos_fk_tradeidkey2trade FOREIGN KEY (trade_id) REFERENCES pos_trade (id),
    CONSTRAINT pos_fk_tradeidkey2idkey FOREIGN KEY (idkey_id) REFERENCES pos_idkey (id)
);
CREATE INDEX ix_pos_trd2idkey_idkey ON pos_trade2idkey(idkey_id);

-------------------------------------
-- Static data
-------------------------------------

create table rsk_observation_time (
    id int not null,
    label varchar(255) not null,                -- LDN_CLOSE
    
    primary key (id),
    
    constraint rsk_chk_uq_obs_time unique (label)
);

create table rsk_observation_datetime (
	id int not null,
	date_part date not null,  
	time_part time null,						-- null if time of LDN_CLOSE not fixed yet
	observation_time_id int not null,    		  
	
	primary key (id),
	
	constraint rsk_fk_obs_datetime2obs_time
	    foreign key (observation_time_id) references rsk_observation_time (id),
	    
	constraint rsk_chk_obs_datetime check 
	    (time_part is not null or observation_time_id is not null), 
	
	constraint rsk_chk_uq_obs_datetime unique (date_part, observation_time_id)
);

create table rsk_compute_host (
	id int not null,
	host_name varchar(255) not null,
	
	primary key (id),
	
	constraint rsk_chk_uq_compute_host unique (host_name)
);

create table rsk_compute_node (
	id int not null,
	compute_host_id int not null,
	node_name varchar(255) not null,
	
	primary key (id),
	
	constraint rsk_fk_cmpt_node2cmpt_host
	    foreign key (compute_host_id) references rsk_compute_host (id),
	    
	constraint rsk_chk_uq_compute_node unique (node_name)
);

create table rsk_opengamma_version (
	id int not null,
	version varchar(255) not null, 
	
	primary key (id),
	
	constraint rsk_chk_uq_opengamma_version unique (version)
);

-- DBTOOLDONOTCLEAR
create table rsk_computation_target_type (
	id int not null,	 	            
    name varchar(255) not null,
    
    primary key (id),
    
    constraint rsk_chk_cmpt_target_type check
        ((id = 0 and name = 'PORTFOLIO_NODE') or
         (id = 1 and name = 'POSITION') or 
         (id = 2 and name = 'SECURITY') or
         (id = 3 and name = 'PRIMITIVE'))
);

insert into rsk_computation_target_type (id, name) values (0, 'PORTFOLIO_NODE');
insert into rsk_computation_target_type (id, name) values (1, 'POSITION');
insert into rsk_computation_target_type (id, name) values (2, 'SECURITY');
insert into rsk_computation_target_type (id, name) values (3, 'PRIMITIVE');

create table rsk_computation_target (
	id int not null,
	type_id int not null,
	id_scheme varchar(255) not null,
	id_value varchar(255) not null,
	id_version varchar(255) null,
	name varchar(255) null,
	
	primary key (id),
	
	constraint rsk_fk_cmpt_target2tgt_type 
	    foreign key (type_id) references rsk_computation_target_type (id),
	    
	constraint rsk_chk_uq_computation_target unique (type_id, id_scheme, id_value, id_version)
);

create table rsk_function_unique_id (
	id int not null,
	unique_id varchar(255) not null,
	
	primary key (id),
	
	constraint rsk_chk_uq_function_unique_id unique (unique_id)
);

-------------------------------------
-- LiveData inputs
-------------------------------------

create table rsk_live_data_field (
	id int not null,
	name varchar(255) not null,
	
	primary key (id),
	
	constraint rsk_chk_uq_live_data_field unique (name)
);

create table rsk_live_data_snapshot (
	id int not null,
	observation_datetime_id int not null,
	
	primary key (id),
	
	constraint rsk_fk_lv_data_snap2ob_dttime
	    foreign key (observation_datetime_id) references rsk_observation_datetime (id),
	    
	constraint rsk_chk_uq_live_data_snapshot unique (observation_datetime_id)
);

create table rsk_live_data_snapshot_entry (
	id bigint not null,
	snapshot_id int not null,
	computation_target_id int not null,
	field_id int not null,
	value double precision,
	
	primary key (id),
	
	constraint rsk_fk_snpsht_entry2snpsht
		foreign key (snapshot_id) references rsk_live_data_snapshot (id),
	constraint rsk_fk_spsht_entry2cmp_target
	    foreign key (computation_target_id) references rsk_computation_target (id),
	    
	constraint rsk_chk_uq_snapshot_entry unique (snapshot_id, computation_target_id, field_id) 	
);

-------------------------------------
-- Risk run
-------------------------------------

create table rsk_run (
    id int not null,
    opengamma_version_id int not null,
    master_process_host_id int not null,    -- machine where 'master' batch process was started
    run_time_id int not null,
    live_data_snapshot_id int not null,
    create_instant timestamp without time zone not null,
    start_instant timestamp without time zone not null,       -- can be different from create_instant if is run is restarted
    end_instant	timestamp without time zone,
    num_restarts int not null,
    complete boolean not null,
    
    primary key (id),
    
    constraint rsk_fk_run2opengamma_version
        foreign key (opengamma_version_id) references rsk_opengamma_version (id),
    constraint rsk_fk_run2compute_host
        foreign key (master_process_host_id) references rsk_compute_host (id),
    constraint rsk_fk_run2obs_datetime
        foreign key (run_time_id) references rsk_observation_datetime (id),
    constraint rsk_fk_run2live_data_snapshot
        foreign key (live_data_snapshot_id) references rsk_live_data_snapshot (id),

    constraint rsk_chk_uq_run unique (run_time_id)
);

create table rsk_calculation_configuration (
	id int not null,
	run_id int not null,
	name varchar(255) not null,
	
	primary key (id),
	
	constraint rsk_fk_calc_conf2run
	    foreign key (run_id) references rsk_run (id),
	
	constraint rsk_chk_uq_calc_conf unique (run_id, name)
);

-- Properties should be filled once only. If already there, use existing value.
--
-- Example properties:
-- 	- PositionMasterTime = 20100615170000
--  - GlobalRandomSeed = 54321
create table rsk_run_property (		
	id int not null,
	run_id int not null,
	property_key varchar(255) not null,
	property_value varchar(2000) not null,		    -- varchar(255) not enough
	
	primary key (id),

	constraint rsk_fk_run_property2run 
	    foreign key (run_id) references rsk_run (id)
);

-- DBTOOLDONOTCLEAR
create table rsk_run_status_code (
    id int not null,	 	            
    name varchar(255) not null,
    
    primary key (id),
    
    constraint rsk_chk_rsk_run_status_code check
        ((id = 0 and name = 'SUCCESS') or
         (id = 1 and name = 'FAILURE') or 
         (id = 2 and name = 'RUNNING') or
         (id = 3 and name = 'NOT_RUNNING'))
);

insert into rsk_run_status_code (id, name) values (0, 'SUCCESS');
insert into rsk_run_status_code (id, name) values (1, 'FAILURE');
insert into rsk_run_status_code (id, name) values (2, 'RUNNING');
insert into rsk_run_status_code (id, name) values (3, 'NOT_RUNNING');

create table rsk_run_status (
    id bigint not null, 
    calculation_configuration_id int not null,
    computation_target_id int not null,
    status int not null,

    constraint rsk_fk_run_status2calc_conf
        foreign key (calculation_configuration_id) references rsk_calculation_configuration (id),
    constraint rsk_fk_run_status2comp_tgt
        foreign key (computation_target_id) references rsk_computation_target (id),
    constraint rsk_fk_run_status2code
        foreign key (status) references rsk_run_status_code (id),

    constraint rsk_chk_uq_run_status unique (calculation_configuration_id, computation_target_id)
);


-------------------------------------
-- Risk
-------------------------------------

create table rsk_value_name (
    id int not null,
    name varchar(255) not null,
    
    primary key (id),
    
    constraint rsk_chk_uq_value_name unique (name)
);

create table rsk_value_specification (
    id int not null,
    synthetic_form varchar(1024) not null,

    primary key (id),

    constraint rsk_chk_uq_value_specification unique (synthetic_form)
);

create table rsk_value_requirement (
    id int not null,
    synthetic_form varchar(1024) not null,

    primary key (id),

    constraint rsk_chk_uq_value_requirement unique (synthetic_form)
);

create table rsk_value (
    id bigint not null,
    calculation_configuration_id int not null,
    value_name_id int not null,
    value_requirement_id int not null,
    value_specification_id int not null,
    function_unique_id int not null,
    computation_target_id int not null,        
    run_id int not null,             	       -- shortcut
    value double precision not null,
    eval_instant timestamp without time zone not null,
    compute_node_id int not null,
    
    primary key (id),
    
    -- performance implications of these requirement?
    constraint rsk_fk_value2calc_conf
        foreign key (calculation_configuration_id) references rsk_calculation_configuration (id),
    constraint rsk_fk_value2run 
        foreign key (run_id) references rsk_run (id),
    constraint rsk_fk_value2value_name
        foreign key (value_name_id) references rsk_value_name (id),
    constraint rsk_fk_value2value_requirement
        foreign key (value_requirement_id) references rsk_value_requirement (id),
    constraint rsk_fk_value2value_specification
        foreign key (value_specification_id) references rsk_value_specification (id),
    constraint rsk_fk_value2function_id
        foreign key (function_unique_id) references rsk_function_unique_id (id),
    constraint rsk_fk_value2comp_target
        foreign key (computation_target_id) references rsk_computation_target (id),
    constraint rsk_fk_value2compute_node
        foreign key (compute_node_id) references rsk_compute_node (id),
        
    constraint rsk_chk_uq_value unique (calculation_configuration_id, value_name_id, value_requirement_id, computation_target_id)
);


create table rsk_compute_failure (			
    id bigint not null,
    function_id varchar(255) not null,
    exception_class varchar(255) not null,
    exception_msg varchar(255) not null,                  
    stack_trace varchar(2000) not null,         -- first 2000 chars. not including msg
    
    primary key (id),
    
    constraint rsk_chk_uq_compute_failure unique (function_id, exception_class, exception_msg, stack_trace)
);

-- how to aggregate risk failures?
create table rsk_failure (			
    id bigint not null,
    calculation_configuration_id int not null,
    value_name_id int not null,
    value_requirement_id int not null,
    value_specification_id int not null,
    function_unique_id int not null,
    computation_target_id int not null,
    run_id int not null,             	       -- shortcut
    eval_instant timestamp without time zone not null,
    compute_node_id int not null,
    
    primary key (id),
    
    constraint rsk_fk_failure2calc_conf 
        foreign key (calculation_configuration_id) references rsk_calculation_configuration (id),
    constraint rsk_fk_failure2run 
        foreign key (run_id) references rsk_run (id),
    constraint rsk_fk_failure2value_name
        foreign key (value_name_id) references rsk_value_name (id),
    constraint rsk_fk_failure2value_requirement
        foreign key (value_requirement_id) references rsk_value_requirement (id),
    constraint rsk_fk_failure2value_specification
        foreign key (value_specification_id) references rsk_value_specification (id),
    constraint rsk_fk_failure2function_id
        foreign key (function_unique_id) references rsk_function_unique_id (id),
    constraint rsk_fk_failure2com_target
        foreign key (computation_target_id) references rsk_computation_target (id),
    constraint rsk_fk_failure2node
       foreign key (compute_node_id) references rsk_compute_node (id),
        
    constraint rsk_chk_uq_failure unique (calculation_configuration_id, value_name_id, value_requirement_id, computation_target_id)
);    

create table rsk_failure_reason (
   id bigint not null,
   rsk_failure_id bigint not null,
   compute_failure_id bigint not null,
   
   primary key (id),
   
   constraint rsk_fk_fail_reason2failure
       foreign key (rsk_failure_id) references rsk_failure (id)
       on delete cascade,
   constraint rsk_fk_fail_reason2cmpt_fail
       foreign key (compute_failure_id) references rsk_compute_failure (id),

   constraint rsk_chk_uq_failure_reason unique (rsk_failure_id, compute_failure_id)
);


-------------------------------------
-- Views
-------------------------------------

create view vw_rsk as
select
rsk_computation_target_type.name as comp_target_type,
rsk_computation_target.id_scheme as comp_target_id_scheme,
rsk_computation_target.id_value as comp_target_id_value,
rsk_computation_target.id_version as comp_target_id_version,
rsk_computation_target.name as comp_target_name,
rsk_run.id as rsk_run_id,
rsk_observation_datetime.date_part as run_date,
rsk_observation_time.label as run_time,
rsk_calculation_configuration.name as calc_conf_name,
rsk_value_name.name,
rsk_value_requirement.synthetic_form as requirement_synthetic_form,
rsk_value_specification.synthetic_form as specification_synthetic_form,
rsk_function_unique_id.unique_id as function_unique_id,
rsk_value.value,
rsk_value.eval_instant
from 
rsk_value, 
rsk_calculation_configuration,
rsk_value_name,
rsk_value_requirement,
rsk_value_specification,
rsk_computation_target,
rsk_computation_target_type,
rsk_run,
rsk_compute_node,
rsk_observation_datetime,
rsk_observation_time,
rsk_function_unique_id
where
rsk_value.calculation_configuration_id = rsk_calculation_configuration.id and
rsk_value.value_name_id = rsk_value_name.id and
rsk_value.value_requirement_id = rsk_value_requirement.id and
rsk_value.value_specification_id = rsk_value_specification.id and
rsk_value.function_unique_id = rsk_function_unique_id.id and
rsk_value.computation_target_id = rsk_computation_target.id and
rsk_computation_target.type_id = rsk_computation_target_type.id and
rsk_value.run_id = rsk_run.id and
rsk_value.compute_node_id = rsk_compute_node.id and
rsk_run.run_time_id = rsk_observation_datetime.id and
rsk_observation_datetime.observation_time_id = rsk_observation_time.id;

create view vw_rsk_failure as
select
rsk_computation_target_type.name as comp_target_type,
rsk_computation_target.id_scheme as comp_target_id_scheme,
rsk_computation_target.id_value as comp_target_id_value,
rsk_computation_target.id_version as comp_target_id_version,
rsk_computation_target.name as comp_target_name,
rsk_run.id as rsk_run_id,
rsk_observation_datetime.date_part as run_date,
rsk_observation_time.label as run_time,
rsk_calculation_configuration.name as calc_conf_name,
rsk_value_name.name,
rsk_value_requirement.synthetic_form as requirement_synthetic_form,
rsk_value_specification.synthetic_form as specification_synthetic_form,
rsk_function_unique_id.unique_id as function_unique_id,
rsk_failure.eval_instant,
rsk_compute_failure.function_id as failed_function,
rsk_compute_failure.exception_class,
rsk_compute_failure.exception_msg,
rsk_compute_failure.stack_trace 
from 
rsk_failure, 
rsk_calculation_configuration,
rsk_value_name,
rsk_value_requirement,
rsk_value_specification,
rsk_computation_target,
rsk_computation_target_type,
rsk_run,
rsk_compute_node,
rsk_observation_datetime,
rsk_observation_time,
rsk_function_unique_id,
rsk_failure_reason,
rsk_compute_failure
where
rsk_failure.calculation_configuration_id = rsk_calculation_configuration.id and
rsk_failure.value_name_id = rsk_value_name.id and
rsk_failure.value_requirement_id = rsk_value_requirement.id and
rsk_failure.value_specification_id = rsk_value_specification.id and
rsk_failure.function_unique_id = rsk_function_unique_id.id and
rsk_failure.computation_target_id = rsk_computation_target.id and
rsk_computation_target.type_id = rsk_computation_target_type.id and
rsk_failure.run_id = rsk_run.id and
rsk_failure.compute_node_id = rsk_compute_node.id and
rsk_run.run_time_id = rsk_observation_datetime.id and
rsk_observation_datetime.observation_time_id = rsk_observation_time.id and
rsk_failure_reason.rsk_failure_id = rsk_failure.id and
rsk_failure_reason.compute_failure_id = rsk_compute_failure.id;
-- create-db-historicaltimeseries.sql: Historical time-series Master

-- design has one main document with data points handled separately
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

-- Data point versioning is slightly different.
-- Data points are inserted on a daily basis with a single version instant.
-- There may be a delay between the value becoming available and the insertion
-- which the version instant models, ensuring the exact state previously viewed.
-- A new version of a point may not be created (the insertion of the point
-- is the versioned item, and treated as being at the document level).
-- A data point may however be corrected. A single instant recorded for this.
-- The actual data point is the latest matching these criteria:
--  hts_point.ver_instant <= search_version_instant &&
--  hts_point.corr_instant <= search_correction_instant

CREATE SEQUENCE hts_master_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
CREATE SEQUENCE hts_idkey_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
CREATE SEQUENCE hts_doc2idkey_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
CREATE SEQUENCE hts_dimension_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby, not accepted by Postgresql

CREATE TABLE hts_name (
    id bigint NOT NULL,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);
CREATE UNIQUE INDEX ix_hts_name_name ON hts_name(name);

CREATE TABLE hts_data_field (
    id bigint NOT NULL,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);
CREATE UNIQUE INDEX ix_hts_data_field_name ON hts_data_field(name);

CREATE TABLE hts_data_source (
    id bigint NOT NULL,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);
CREATE UNIQUE INDEX ix_hts_data_source_name ON hts_data_source(name);

CREATE TABLE hts_data_provider (
    id bigint NOT NULL,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);
CREATE UNIQUE INDEX ix_hts_data_provider_name ON hts_data_provider(name);

CREATE TABLE hts_observation_time (
    id bigint NOT NULL,
    name varchar(255) NOT NULL,
    PRIMARY KEY (id)
);
CREATE UNIQUE INDEX ix_hts_observation_time_name ON hts_observation_time(name);

CREATE TABLE hts_document (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name_id bigint NOT NULL,
    data_field_id bigint NOT NULL,
    data_source_id bigint NOT NULL,
    data_provider_id bigint NOT NULL,
    observation_time_id bigint NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT hts_fk_doc2doc FOREIGN KEY (oid) REFERENCES hts_document (id),
    CONSTRAINT hts_chk_doc_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT hts_chk_doc_corr_order CHECK (corr_from_instant <= corr_to_instant),
    CONSTRAINT hts_fk_doc2name FOREIGN KEY (name_id) REFERENCES hts_name (id),
    CONSTRAINT hts_fk_doc2data_field FOREIGN KEY (data_field_id) REFERENCES hts_data_field (id),
    CONSTRAINT hts_fk_doc2data_source FOREIGN KEY (data_source_id) REFERENCES hts_data_source (id),
    CONSTRAINT hts_fk_doc2data_provider FOREIGN KEY (data_provider_id) REFERENCES hts_data_provider (id),
    CONSTRAINT hts_fk_doc2observation_time FOREIGN KEY (observation_time_id) REFERENCES hts_observation_time (id)
);
CREATE INDEX ix_hts_hts_oid ON hts_document(oid);
CREATE INDEX ix_hts_hts_ver_from_instant ON hts_document(ver_from_instant);
CREATE INDEX ix_hts_hts_ver_to_instant ON hts_document(ver_to_instant);
CREATE INDEX ix_hts_hts_corr_from_instant ON hts_document(corr_from_instant);
CREATE INDEX ix_hts_hts_corr_to_instant ON hts_document(corr_to_instant);
CREATE INDEX ix_hts_hts_name_id ON hts_document(name_id);
CREATE INDEX ix_hts_hts_data_field ON hts_document(data_field_id);
CREATE INDEX ix_hts_hts_data_source ON hts_document(data_source_id);
CREATE INDEX ix_hts_hts_data_provider ON hts_document(data_provider_id);
CREATE INDEX ix_hts_hts_observation_time ON hts_document(observation_time_id);

CREATE TABLE hts_idkey (
    id bigint NOT NULL,
    key_scheme varchar(255) NOT NULL,
    key_value varchar(255) NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT hts_chk_idkey UNIQUE (key_scheme, key_value)
);
CREATE INDEX ix_hts_key_schemevalue ON hts_idkey(key_scheme, key_value);
CREATE INDEX ix_hts_key_value ON hts_idkey(key_value);

CREATE TABLE hts_doc2idkey (
    id bigint NOT NULL DEFAULT nextval('hts_doc2idkey_seq'),
    doc_id bigint NOT NULL,
    idkey_id bigint NOT NULL,
    valid_from date NOT NULL,
    valid_to date NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT hts_fk_htsidkey2doc FOREIGN KEY (doc_id) REFERENCES hts_document (id),
    CONSTRAINT hts_fk_htsidkey2idkey FOREIGN KEY (idkey_id) REFERENCES hts_idkey (id),
    CONSTRAINT hts_chk_doc2idkey UNIQUE (doc_id, idkey_id, valid_from, valid_to)
);
CREATE INDEX ix_hts_doc2idkey_idkey ON hts_doc2idkey(idkey_id, valid_from, valid_to);
-- hts_doc2idkey is fully dependent of hts_document

CREATE TABLE hts_point (
    doc_oid bigint NOT NULL,
    point_date date NOT NULL,
    ver_instant timestamp without time zone NOT NULL,
    corr_instant timestamp without time zone NOT NULL,
    point_value double precision,
    PRIMARY KEY (doc_oid, point_date, ver_instant, corr_instant)
);
-- null value used to indicate point was deleted


-- create-db-marketdatasnapshot.sql

-- MarketDataSnapshotMaster design has one document
--  snapshot
-- bitemporal versioning exists at the document level
-- each time a document is changed, a new row is written
-- with only the end instant being changed on the old row

CREATE SEQUENCE snp_snapshot_seq
    START WITH 1000 INCREMENT BY 1 NO CYCLE;
-- "as bigint" required by Derby/HSQL, not accepted by Postgresql

CREATE TABLE snp_snapshot (
    id bigint NOT NULL,
    oid bigint NOT NULL,
    ver_from_instant timestamp without time zone NOT NULL,
    ver_to_instant timestamp without time zone NOT NULL,
    corr_from_instant timestamp without time zone NOT NULL,
    corr_to_instant timestamp without time zone NOT NULL,
    name varchar(255) NOT NULL,
    time_zone varchar(255),
    detail bytea NOT NULL,
    PRIMARY KEY (id),
    CONSTRAINT snp_chk_snapshot_ver_order CHECK (ver_from_instant <= ver_to_instant),
    CONSTRAINT snp_chk_snapshot_corr_order CHECK (corr_from_instant <= corr_to_instant)
);
CREATE INDEX ix_snp_snapshot_oid ON snp_snapshot(oid);
CREATE INDEX ix_snp_snapshot_ver_from_instant ON snp_snapshot(ver_from_instant);
CREATE INDEX ix_snp_snapshot_ver_to_instant ON snp_snapshot(ver_to_instant);
CREATE INDEX ix_snp_snapshot_corr_from_instant ON snp_snapshot(corr_from_instant);
CREATE INDEX ix_snp_snapshot_corr_to_instant ON snp_snapshot(corr_to_instant);
CREATE INDEX ix_snp_snapshot_name ON snp_snapshot(name);
CREATE INDEX ix_snp_snapshot_nameu ON snp_snapshot(UPPER(name));


