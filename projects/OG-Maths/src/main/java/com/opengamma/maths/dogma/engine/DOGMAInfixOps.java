// AUTOGENERATED WITH
// cpp -C DOGMAInfixOps.javap |sed '/^#.*/d' DOGMAInfixOps.javap > DOGMAInfixOps.java
// DO NOT EDIT MANUALLY 
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 * 
 * Please see distribution for license.
 */
package com.opengamma.maths.dogma.engine;

import com.opengamma.maths.commonapi.numbers.ComplexType;
import com.opengamma.maths.dogma.engine.language.InfixOperator;
import com.opengamma.maths.dogma.engine.ldivide.Ldivide;
import com.opengamma.maths.dogma.engine.minus.Minus;
import com.opengamma.maths.dogma.engine.mldivide.Mldivide;
import com.opengamma.maths.dogma.engine.mrdivide.Mrdivide;
import com.opengamma.maths.dogma.engine.mtimes.Mtimes;
import com.opengamma.maths.dogma.engine.operationstack.InfixOpChain;
import com.opengamma.maths.dogma.engine.operationstack.MethodScraperForInfixOperators;
import com.opengamma.maths.dogma.engine.operationstack.RunInfixOpChain;
import com.opengamma.maths.dogma.engine.plus.Plus;
import com.opengamma.maths.dogma.engine.rdivide.Rdivide;
import com.opengamma.maths.dogma.engine.times.Times;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGArray;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGComplexScalar;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGMatrix;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGRealScalar;

/**
 * 
 */
public class DOGMAInfixOps {

  // single
  private static DOGMAInfixOps s_instance;

  DOGMAInfixOps() {
  }

  public static DOGMAInfixOps getInstance() {
    return s_instance;
  }

  private static InfixOpChain[][] s_plusInstructions;
  private static InfixOpChain[][] s_minusInstructions;
  private static InfixOpChain[][] s_mtimesInstructions;
  private static InfixOpChain[][] s_timesInstructions;
  private static InfixOpChain[][] s_rdivideInstructions;
  private static InfixOpChain[][] s_mrdivideInstructions;
  private static InfixOpChain[][] s_ldivideInstructions;
  private static InfixOpChain[][] s_mldivideInstructions;

  private static RunInfixOpChain s_runner = new RunInfixOpChain();
  static {
    // hacky approx costs of evaluation
    final double[][] FunctionEvalCosts = new double[][] {//
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//
        {0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//
        {0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },//
        {0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//
        {0, 0, 0, 0, 0, 0, 25, 0, 50, 0 },//
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },//
        {0, 0, 0, 0, 0, 0, 50, 0, 100, 200 },//
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 200 } };
    // Build instructions sets
    OperatorDictionaryPopulator<InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>> operatorDict = new OperatorDictionaryPopulator<InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>>();

    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] plusFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(operatorDict.getOperationsMap(),
        Plus.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] minusFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(operatorDict.getOperationsMap(),
        Minus.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] mtimesFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(operatorDict.getOperationsMap(),
        Mtimes.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] timesFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(operatorDict.getOperationsMap(),
        Times.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] rdivideFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(operatorDict.getOperationsMap(),
        Rdivide.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] mrdivideFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(
        operatorDict.getOperationsMap(), Mrdivide.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] ldivideFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(operatorDict.getOperationsMap(),
        Ldivide.class);
    InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] mldivideFunctionTable = MethodScraperForInfixOperators.availableMethodsForInfixOp(
        operatorDict.getOperationsMap(), Mldivide.class);

    OGMatrix functionEvalCostsMatrix = new OGMatrix(FunctionEvalCosts);

    s_plusInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), plusFunctionTable, functionEvalCostsMatrix);
    s_minusInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), minusFunctionTable, functionEvalCostsMatrix);
    s_mtimesInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), mtimesFunctionTable, functionEvalCostsMatrix);
    s_timesInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), timesFunctionTable, functionEvalCostsMatrix);
    s_rdivideInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), rdivideFunctionTable, functionEvalCostsMatrix);
    s_mrdivideInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), mrdivideFunctionTable, functionEvalCostsMatrix);
    s_ldivideInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), ldivideFunctionTable, functionEvalCostsMatrix);
    s_mldivideInstructions = MethodScraperForInfixOperators.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), mldivideFunctionTable, functionEvalCostsMatrix);
    ;
  }

  // generates all the functions  
  public static OGArray<? extends Number> plus(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_plusInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> plus(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_plusInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> plus(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_plusInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> minus(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_minusInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> minus(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_minusInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> minus(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_minusInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> mtimes(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mtimesInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> mtimes(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mtimesInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> mtimes(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mtimesInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> times(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_timesInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> times(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_timesInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> times(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_timesInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> rdivide(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_rdivideInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> rdivide(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_rdivideInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> rdivide(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_rdivideInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> mrdivide(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mrdivideInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> mrdivide(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mrdivideInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> mrdivide(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mrdivideInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> ldivide(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_ldivideInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> ldivide(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_ldivideInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> ldivide(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_ldivideInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

  public static OGArray<? extends Number> mldivide(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mldivideInstructions[type1][type2], arg1, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> mldivide(Number arg1, OGArray<? extends Number> arg2) {
    OGArray<? extends Number> arg1rewrite;
    if (arg1.getClass() == ComplexType.class) {
      arg1rewrite = new OGComplexScalar(arg1);
    } else {
      arg1rewrite = new OGRealScalar(arg1);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mldivideInstructions[type1][type2], arg1rewrite, arg2);
    return tmp;
  }

  public static OGArray<? extends Number> mldivide(OGArray<? extends Number> arg1, Number arg2) {
    OGArray<? extends Number> arg2rewrite;
    if (arg2.getClass() == ComplexType.class) {
      arg2rewrite = new OGComplexScalar(arg2);
    } else {
      arg2rewrite = new OGRealScalar(arg2);
    }
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());
    OGArray<? extends Number> tmp = s_runner.dispatch(s_mldivideInstructions[type1][type2], arg1, arg2rewrite);
    return tmp;
  }

}
