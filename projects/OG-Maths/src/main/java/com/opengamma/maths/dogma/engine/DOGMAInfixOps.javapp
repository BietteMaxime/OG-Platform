// AUTOGENERATED WITH
// cpp -C DOGMAInfixOps.javapp |sed '/^#.*/d' > DOGMAInfixOps.java
// DO NOT EDIT MANUALLY 
#define INFIXOPSCAN(_LOWER_,_UPPER_) InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>[][] _LOWER_##FunctionTable = MethodScraper.availableMethodsForInfixOp(operatorDict.getOperationsMap(),_UPPER_.class);
#define IMPORT(_LOWER_,_UPPER_) import com.opengamma.maths.highlevelapi.engine._LOWER_._UPPER_; 
#define REGISTEREDFUNCTION(_LOWER_,_NUL_)   public static OGArray<? extends Number> _LOWER_(OGArray<? extends Number> arg1, OGArray<? extends Number> arg2) {\
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());\
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());\
    OGArray<? extends Number> tmp = s_runner.dispatch(s_##_LOWER_##Instructions[type1][type2], arg1, arg2);\
    return tmp;\
  }

#define REGISTEREDFUNCTION_NUMERIC1(_LOWER_,_NUL_)   public static OGArray<? extends Number> _LOWER_(Number arg1, OGArray<? extends Number> arg2) {\
    OGArray<? extends Number> arg1rewrite;\
    if (arg1.getClass() == ComplexType.class) {\
      arg1rewrite = new OGComplexScalar(arg1);\
    } else {\
      arg1rewrite = new OGRealScalar(arg1);\
    }\
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg1rewrite.getClass());\
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg2.getClass());\
    OGArray<? extends Number> tmp = s_runner.dispatch(s_##_LOWER_##Instructions[type1][type2], arg1rewrite, arg2);\
    return tmp;\
  }\

#define REGISTEREDFUNCTION_NUMERIC2(_LOWER_,_NUL_)  public static OGArray<? extends Number> _LOWER_(OGArray<? extends Number> arg1, Number arg2) {\
    OGArray<? extends Number> arg2rewrite;\
    if (arg2.getClass() == ComplexType.class) {\
      arg2rewrite = new OGComplexScalar(arg2);\
    } else {\
      arg2rewrite = new OGRealScalar(arg2);\
    }\
    int type1 = MatrixTypeToIndexMap.getIndexFromClass(arg2rewrite.getClass());\
    int type2 = MatrixTypeToIndexMap.getIndexFromClass(arg1.getClass());\
    OGArray<? extends Number> tmp = s_runner.dispatch(s_##_LOWER_##Instructions[type1][type2], arg1, arg2rewrite);\
    return tmp;\
  }\
  
#define AGGREGATE_REGISTERED(_LOWER_,NULL) REGISTEREDFUNCTION(_LOWER_,_NUL_) REGISTEREDFUNCTION_NUMERIC1(_LOWER_,_NUL_) REGISTEREDFUNCTION_NUMERIC2(_LOWER_,NULL)
  
#define STATICVARDECL(_LOWER_,_UPPER_)  private static InfixOpChain[][] s_##_LOWER_##Instructions;
#define ASSIGNINSTRUCTIONS(_LOWER_,_NUL_) s_##_LOWER_##Instructions = MethodScraper.computeFunctions(ConversionCostAdjacencyMatrixStore.getWeightedAdjacencyMatrix(), _LOWER_##FunctionTable, functionEvalCostsMatrix);

#define APPLY_FOREACH_OVER_2ARG(FUNC) \
FUNC(plus,Plus)\
FUNC(minus,Minus)\
FUNC(mtimes,Mtimes)\
FUNC(times,Times)\
FUNC(rdivide,Rdivide)\
FUNC(mrdivide,Mrdivide)\
FUNC(ldivide,Ldivide)\
FUNC(mldivide,Mldivide)



/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 * 
 * Please see distribution for license.
 */
package com.opengamma.maths.highlevelapi.engine;

import com.opengamma.maths.commonapi.numbers.ComplexType;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGArray;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGComplexScalar;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGMatrix;
import com.opengamma.maths.highlevelapi.datatypes.primitive.OGRealScalar;
import com.opengamma.maths.highlevelapi.engine.language.InfixOperator;
import com.opengamma.maths.highlevelapi.engine.operationstack.InfixOpChain;
import com.opengamma.maths.highlevelapi.engine.operationstack.MethodScraper;
import com.opengamma.maths.highlevelapi.engine.operationstack.RunInfixOpChain;
APPLY_FOREACH_OVER_2ARG(IMPORT)


/**
 * 
 */
public class DOGMAInfixOps {

  // single
  private static DOGMAInfixOps s_instance;

  DOGMAInfixOps() {
  }

  public static DOGMAInfixOps getInstance() {
    return s_instance;
  }

  APPLY_FOREACH_OVER_2ARG(STATICVARDECL)
  
  private static RunInfixOpChain s_runner = new RunInfixOpChain();
  static {
    // hacky approx costs of evaluation
    final double[][] FunctionEvalCosts = new double[][] {//
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },//
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },//
        {0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },//
        {0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },//
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },//
        {0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },//
        {0, 0, 0, 0, 0, 0, 25, 0, 50, 0 },//
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },//
        {0, 0, 0, 0, 0, 0, 50, 0, 100, 200 },//
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 200 } };
    // Build instructions sets
    OperatorDictionaryPopulator<InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>> operatorDict = new OperatorDictionaryPopulator<InfixOperator<OGArray<? extends Number>, OGArray<? extends Number>, OGArray<? extends Number>>>();
    
    APPLY_FOREACH_OVER_2ARG(INFIXOPSCAN)        
        
    OGMatrix functionEvalCostsMatrix = new OGMatrix(FunctionEvalCosts);

    APPLY_FOREACH_OVER_2ARG(ASSIGNINSTRUCTIONS); 
  }

// generates all the functions  
  APPLY_FOREACH_OVER_2ARG(AGGREGATE_REGISTERED)  

}
