\section{Introduction}

This document covers how to write documentation for OpenGamma code using Dexy.

\section{Hello, World Examples}

Examples form the basis for documenting features and also for creating plots
and other visual assets to be used in white papers. In this section, we create
some very simple examples to introduce basic Dexy concepts. As a prerequisite,
you should read the page on
\href{http://www.dexy.it/docs/guide/documents-dependencies-and-filters/}{Documents, Dependencies and Filters}
from the \url{http://dexy.it} website which describes running Dexy, writing
\verb|.dexy| files and using filters.

The examples directory has a \verb|.dexy| file which should cover many basic
cases. You can put an additional \verb|.dexy| file in your example directory,
but you shouldn't need to for straightforward examples. Here is the .dexy file
in the examples directory. In Dexy, the configuration in a .dexy file is
applied to the directory it's in, along with any subdirectories (unless
instructed otherwise).

<< d['.dexy|ppjson|pyg|l'] >>

So, among other things, we can see that all \verb|.java| files will be run
through the fn filter, then the java filter. The fn filter helps manage
filenames for data files or images. It is described in
\href{http://www.dexy.it/docs/filters/FilenameFilter-(fn).html}{this filter reference page}.
The java filter will compile and then run the code. It is described in
\href{http://www.dexy.it/docs/filters/JavaFilter-(java).html}{this filter reference page}.

\subsection{Hello, World Example}

We'll write a short self-contained script that uses a simple OpenGamma class.

Here is the script:

%%% @export "hello-og-world-source"
<< d['hello-og-world/HelloOpenGammaWorldExample.java|pyg|l'] >>
%%% @end

And here is the output from running the script via dexy:

%%% @export "hello-og-world-output"
\begin{Verbatim}
<< d['hello-og-world/HelloOpenGammaWorldExample.java|fn|java'] >>
\end{Verbatim}
%%% @end

The point of this script is that (a) it's very simple and (b) it connects to an
OpenGamma class so we know our CLASSPATH etc. is working.

Here is the file in the \verb|hello-og-world| directory:

\begin{Verbatim}
<< d['hello-og-world/list-files.sh|jinja|sh'] >>
\end{Verbatim}

The syntax highlighted source code can be pulled into a LaTeX document by:

<< d['writing-docs.tex|idio|l']['hello-og-world-source'] >>

And the output can be pulled in by:

<< d['writing-docs.tex|idio|l']['hello-og-world-output'] >>

The \verb=|l= filter at the end forces the previous filter to output \LaTeX. If
you are writing a HTML document you would leave this off (and use \lt pre \gt tags to
display plain text instead of creating a Verbatim environment).

\subsection{Longer Hello, World Example}

Now we'll have a slightly longer example in order to demonstrate how we split
our code into sections.

Here is the complete source code of the example:

%%% @export "hello-og-world-longer-source"
<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|pyg|l'] >>
%%% @end

The comments starting with \verb|// @export| are special comments recognized
by the \verb|idio| filter which split the source code up into sections. We can
pull these sections in to documents individually, so we can discuss sections of
the code in detail.

For example, here is the `imports' section where we list the packages we wish to import:

%%% @export "hello-og-world-longer-source"
<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['imports'] >>
%%% @end

Here is how that section is pulled in to this document:

<< d['writing-docs.tex|idio|l']['hello-og-world-longer-source'] >>

Next we have our class definition:

<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['class-def'] >>

We initalize a complex number:

<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['init'] >>

And we do some trigonometric calculations:

<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['calculate'] >>

Here is the output:

%%% @export "hello-og-world-longer-output"
\begin{Verbatim}
<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|fn|java'] >>
\end{Verbatim}
%%% @end

Dividing this code up into sections allows us to explain each part in detail,
without overwhelming the reader with an entire script.

\subsection{Saving Data}

In this section we will write a script that writes data to a file. We will then
be able to show that file in our document.

Here are the imports:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['imports'] >>

Next we define the class and start a \verb|main| method:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['class-def'] >>

We open a data file and a PrintStream to write to this file:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['open-data-file'] >>

By starting the file name with \verb|dexy--| we are telling the Filename (fn)
filter to replace that canonical filename with a special filename which will
help us share our data with other documents. You don't need to worry about the
details, just keep in mind that if you want to write data to a file so it can
be used later or included in your documents, you should start the filename with
\verb|dexy--| and run your script through the \verb|fn| filter before you run
the code.

Java is a special case in Dexy. Normally, Dexy runs scripts by saving them in
the \verb|artifacts/| directory under a special filename. However, Java
requires that classes are defined in files with a matching name. So, for Java,
Dexy creates a directory with a special name and saves the script in that
directory under its canonical name. However, when we use the filename filter to
create a data file, it expects the data file to be created in the artifacts
directory rather than a subdirectory. So, for Java, you need to prefix your
data file name with \verb|..|.

Now that we have our print stream set up, we can write our content to the file
rather than System.out.

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['init'] >>
<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['calculate'] >>

Finally, we close the data stream:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['close-data-file'] >>

Here is what was written to the data file:

%%% @export "hello-og-world-data-file"
\begin{Verbatim}
<< d['hello-og-world-data/hello-world-data.txt'] >>
\end{Verbatim}
%%% @end

And here is how we pulled that into this document:

<< d['writing-docs.tex|idio|l']['hello-og-world-data-file'] >>

You can use the filename to help manage any type of file. Typically we will
create .txt or .csv files (it could even be a .sqlite3 file) to share data
between a script which generates the data, and another which analyzes or plots
the data (which can be in another programming language). We will also use the
filename filter to manage the .png or .pdf filenames that the plots go in.

\section{Referencing Source Code}

In the previous section, we looked at creating small, self-contained examples
which make use of OpenGamma classes. However, we might also want to pull in
extra information about those classes, such as Javadoc comments or the actual
source code of the methods.

In this section, we will look at how to pull that information in to a document.

In the next section, we will go through writing an extensive example in Java
and also writing up documentation for the example, including pulling in the
source code, the results, and documentation for the classes we reference.

The json-doclet project is part of Dexy, and it lets us run a custom Javadoc
\href{http://download.oracle.com/javase/6/docs/technotes/guides/javadoc/doclet/overview.html}{Doclet}
which gathers all the Javadoc information plus extracts source code, and
writes all this information to a JSON file.

Within our Dexy documents, we can pull information out of this JSON dict. A
special Dexy filter adds some nice features like syntax highlighting the Java
source code stored in the dict. You can view the filter reference documentation
for the \href{http://dexy.it/docs/filters/javadoc}{javadoc filter}.

%%% @export "assign-class-to-local-variable"
<% set cn_class = d['/javadoc-data.json|javadocs']['packages']['com.opengamma.math.number']['classes']['ComplexNumber'] %>
%%% @end

When working with a class, it can be useful to assign that branch of the dict to a local variable:

\fvset{fontsize=\scriptsize}
<< d['writing-docs.tex|idio|l']['assign-class-to-local-variable'] >>
\fvset{fontsize=\small}

Then we can access class comment text via:

<< d['writing-docs.tex|idio|l']['class-comment-text'] >>

Here is the comment for this class:

%%% @export "class-comment-text"
<< cn_class['comment-text'] >>
%%% @end

We can iterate over methods in the class docs via:

<< d['writing-docs.tex|idio|l']['print-methods'] >>

Documentation is available for the following methods:

%%% @export "print-methods"
\begin{itemize}
<% for name in cn_class['methods'].keys() -%>
\item{<< name >>}
<% endfor -%>
\end{itemize}
%%% @end

We can iterate over constructors in the class docs via:

<< d['writing-docs.tex|idio|l']['print-constructors'] >>

Documentation is available for the following constructors:

%%% @export "print-constructors"
\begin{itemize}
<% for name in cn_class['constructors'].keys() -%>
\item{<< name >>}
<% endfor -%>
\end{itemize}
%%% @end

In the previous section, we used the following constructor:

<< cn_class['constructors']['ComplexNumber(double,double)']['source-latex'] >>

If we didn't have an imagniary component, we could have used an alternate constructor:

\begin{Verbatim}
<< cn_class['constructors']['ComplexNumber(double)']['comment-text'] >>
\end{Verbatim}
<< cn_class['constructors']['ComplexNumber(double)']['source-latex'] >>

Here is the source of the \verb|toString()| method:

<< cn_class['methods']['toString()']['source-latex'] >>

\section{A Real Example}

In this section we discuss writing the SABR extrapolation example. The example
is adapted from a unit test.

<% set sabr_class = d['/javadoc-data.json|javadocs']['packages']['com.opengamma.financial.model.option.pricing.analytic.formula']['classes']['SABRExtrapolationRightFunction'] %>

First we look at some of the docs and source of the classes we will use in our
example.

\subsection{SABRExtrapolationRightFunction Class}

<< sabr_class['comment-text'] >>

We will want to create an instance of this function. Here is the constructor:

\fvset{fontsize=\footnotesize}
<< sabr_class['constructors']['SABRExtrapolationRightFunction(double,SABRFormulaData,double,double,double)']['source-latex'] >>
\fvset{fontsize=\small}

Then we will use the \verb|price| function.

<< sabr_class['methods']['price(EuropeanVanillaOption)']['comment-text'] >>
\fvset{fontsize=\footnotesize}
<< sabr_class['methods']['price(EuropeanVanillaOption)']['source-latex'] >>
\fvset{fontsize=\small}

\subsection{SABRFormulaData}

The other class we use is SABRFormulaData.

<% set sabr_formula_data_class = d['/javadoc-data.json|javadocs']['packages']['com.opengamma.financial.model.volatility.smile.function']['classes']['SABRFormulaData'] %>

<< sabr_formula_data_class['constructors']['SABRFormulaData(double,double,double,double)']['source-latex'] >>

\subsection{Example}

Here are our imports:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['imports'] >>

And the class definition:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['class-def'] >>

We define constants used in the SABRFormulaData constructor, and then create a
\verb|SABR_DATA| constant:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['class-constants-sabr-data'] >>

Next we set some more constants we will use in our calculations:
<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['class-constants-sabr-extrapolation-function'] >>

Now we enter the main method, where we declare some local variables and set up
some more formulas and data we will need:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['main'] >>

We set up the data file we will store our data in, and write the field header line:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['data-file'] >>

Now we're all set, and we can enter our main loop and calculate the option
price over a range of strikes, and also calculate the implied volatility:

\fvset{fontsize=\scriptsize}
<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['loop'] >>
\fvset{fontsize=\small}

Finally, we close the data stream, ensuring all our data is written to a file:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['save-data'] >>

Here is the first few lines of the generated data:

\begin{Verbatim}
<< "\n".join(d['sabr-extrapolation/smile-multi-mu-data.txt'].splitlines()[0:10]) >>
\end{Verbatim}

\subsection{Plotting Data in R}

The reason we have generated this data is to make use of it. In this case, we
want to plot this data in R. The examples repository is configured so that if
you create a .R file with the same name as the .java file, this R file will
be run automatically, after the .java file has been, so it can make use of any
data files generated by the java.

At the top of our R script, we state which libraries we will need:

<< d['sabr-extrapolation/SabrExtrapolationExample.R|idio|l']['libraries'] >>

Next we read the generated data into a variable creatively named \verb|data|:

<< d['sabr-extrapolation/SabrExtrapolationExample.R|idio|l']['read-data'] >>

We need to calculate the density separately for each value of Mu. To simplify
this, we begin by creating variables to hold Price and Strike for different
values of Mu.

<< d['sabr-extrapolation/SabrExtrapolationExample.R|idio|l']['extract-data-by-mu'] >>

Next we calculate density for each of the values of Mu, and add the
concatenated vectors back into our original data object.

<< d['sabr-extrapolation/SabrExtrapolationExample.R|idio|l']['calculate-density'] >>

Now we are ready to plot. To start with, we plot the option price against the strike price:

<< d['sabr-extrapolation/SabrExtrapolationExample.R|idio|l']['plot-data-pdf'] >>

%%% @export "include-extrapolation-price-pdf"
\includegraphics{<< a['sabr-extrapolation/extrapolation-price.pdf'].filename() >>}
%%% @end

Because we are working in \LaTeX, we use the \verb|includegraphics| commands
and reference the dexy artifact corresponding to the plot we want to include,
and call that artifact's \verb|filename()| method:

<< d['writing-docs.tex|idio|l']['include-extrapolation-price-pdf'] >>

By the time we run \LaTeX, our expression has been replaced with the name of
the PDF file we want to include.

Here is the second plot, of the implied volatility against the strike price:

<< d['sabr-extrapolation/SabrExtrapolationExample.R|idio|l']['plot-implied-vol-pdf'] >>

\includegraphics{<< a['sabr-extrapolation/extrapolation-smile.pdf'].filename() >>}

\subsection{Saving Field Values}

For one last trick, we have added some code to allow us to automatically report
on all the field values we defined. Eventually, when this is more developed, it
will be integrated with Dexy so you don't need to insert the code in every
example to make use of it (similar functionality is available for R and
Python). For now, the code is just at the end of the \verb|main| method.

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['save-fields'] >>

This code uses Java introspection to iterate over all the class fields and
write the field names and values to a JSON dict. This means that in our
documents, we can say that

%%% @export "alpha"
$\alpha=<<d['sabr-extrapolation/sabr-fields.json']['ALPHA']>>$
%%% @end

By typing: << d['writing-docs.tex|idio|l']['alpha'] >>
i.e. without hard-coding that value into our document.

Here are all the field values for this example:

\begin{Verbatim}
<% for field, value in d['sabr-extrapolation/sabr-fields.json'].iteritems() -%>
<< field >> : << value >>
<% endfor -%>
\end{Verbatim}
