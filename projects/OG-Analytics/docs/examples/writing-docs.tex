\section{Introduction}

This document covers how to write documentation for OpenGamma code using Dexy.

\section{Hello, World Examples}

Examples form the basis for documenting features and also for creating plots
and other visual assets to be used in white papers. In this section, we create
some very simple examples to introduce basic Dexy concepts. As a prerequisite,
you should read the page on
\href{http://www.dexy.it/docs/guide/documents-dependencies-and-filters/}{Documents, Dependencies and Filters}
from the \url{http://dexy.it} website which describes running Dexy, writing
\verb|.dexy| files and using filters.

The examples directory has a \verb|.dexy| file which should cover many basic
cases. You can put an additional \verb|.dexy| file in your example directory,
but you shouldn't need to for straightforward examples. Here is the .dexy file
in the examples directory. In Dexy, the configuration in a .dexy file is
applied to the directory it's in, along with any subdirectories (unless
instructed otherwise).

<< d['.dexy|ppjson|pyg|l'] >>

So, among other things, we can see that all \verb|.java| files will be run
through the fn filter, then the java filter. The fn filter helps manage
filenames for data files or images. It is described in
\href{http://www.dexy.it/docs/filters/FilenameFilter-(fn).html}{this filter reference page}.
The java filter will compile and then run the code. It is described in
\href{http://www.dexy.it/docs/filters/JavaFilter-(java).html}{this filter reference page}.

\subsection{Hello, World Example}

We'll write a short self-contained script that uses a simple OpenGamma class.

Here is the script:

%%% @export "hello-og-world-source"
<< d['hello-og-world/HelloOpenGammaWorldExample.java|pyg|l'] >>
%%% @end

And here is the output from running the script via dexy:

%%% @export "hello-og-world-output"
\begin{Verbatim}
<< d['hello-og-world/HelloOpenGammaWorldExample.java|fn|java'] >>
\end{Verbatim}
%%% @end

The point of this script is that (a) it's very simple and (b) it connects to an
OpenGamma class so we know our CLASSPATH etc. is working.

Here is the file in the \verb|hello-og-world| directory:

\begin{Verbatim}
<< d['hello-og-world/list-files.sh|jinja|sh'] >>
\end{Verbatim}

The syntax highlighted source code can be pulled into a LaTeX document by:

<< d['writing-docs.tex|idio|l']['hello-og-world-source'] >>

And the output can be pulled in by:

<< d['writing-docs.tex|idio|l']['hello-og-world-output'] >>

The \verb=|l= filter at the end forces the previous filter to output \LaTeX. If
you are writing a HTML document you would leave this off (and use \lt pre \gt tags to
display plain text instead of creating a Verbatim environment).

\subsection{Longer Hello, World Example}

Now we'll have a slightly longer example in order to demonstrate how we split
our code into sections.

Here is the complete source code of the example:

%%% @export "hello-og-world-longer-source"
<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|pyg|l'] >>
%%% @end

The comments starting with \verb|// @export| are special comments recognized
by the \verb|idio| filter which split the source code up into sections. We can
pull these sections in to documents individually, so we can discuss sections of
the code in detail.

For example, here is the `imports' section where we list the packages we wish to import:

%%% @export "hello-og-world-longer-source"
<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['imports'] >>
%%% @end

Here is how that section is pulled in to this document:

<< d['writing-docs.tex|idio|l']['hello-og-world-longer-source'] >>

Next we have our class definition:

<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['class-def'] >>

We initalize a complex number:

<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['init'] >>

And we do some trigonometric calculations:

<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|idio|l']['calculate'] >>

Here is the output:

%%% @export "hello-og-world-longer-output"
\begin{Verbatim}
<< d['hello-og-world-longer/HelloOpenGammaWorldLongerExample.java|fn|java'] >>
\end{Verbatim}
%%% @end

Dividing this code up into sections allows us to explain each part in detail,
without overwhelming the reader with an entire script.

\subsection{Saving Data}

In this section we will write a script that writes data to a file. We will then
be able to show that file in our document.

Here are the imports:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['imports'] >>

Next we define the class and start a \verb|main| method:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['class-def'] >>

We open a data file and a PrintStream to write to this file:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['open-data-file'] >>

By starting the file name with \verb|dexy--| we are telling the Filename (fn)
filter to replace that canonical filename with a special filename which will
help us share our data with other documents. You don't need to worry about the
details, just keep in mind that if you want to write data to a file so it can
be used later or included in your documents, you should start the filename with
\verb|dexy--| and run your script through the \verb|fn| filter before you run
the code.

Java is a special case in Dexy. Normally, Dexy runs scripts by saving them in
the \verb|artifacts/| directory under a special filename. However, Java
requires that classes are defined in files with a matching name. So, for Java,
Dexy creates a directory with a special name and saves the script in that
directory under its canonical name. However, when we use the filename filter to
create a data file, it expects the data file to be created in the artifacts
directory rather than a subdirectory. So, for Java, you need to prefix your
data file name with \verb|..|.

Now that we have our print stream set up, we can write our content to the file
rather than System.out.

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['init'] >>
<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['calculate'] >>

Finally, we close the data stream:

<< d['hello-og-world-data/HelloOpenGammaWorldLongerExample.java|idio|l']['close-data-file'] >>

Here is what was written to the data file:

%%% @export "hello-og-world-data-file"
\begin{Verbatim}
<< d['hello-og-world-data/hello-world-data.txt'] >>
\end{Verbatim}
%%% @end

And here is how we pulled that into this document:

<< d['writing-docs.tex|idio|l']['hello-og-world-data-file'] >>

You can use the filename to help manage any type of file. Typically we will
create .txt or .csv files (it could even be a .sqlite3 file) to share data
between a script which generates the data, and another which analyzes or plots
the data (which can be in another programming language). We will also use the
filename filter to manage the .png or .pdf filenames that the plots go in.

\section{Referencing Source Code}

In the previous section, we looked at creating small, self-contained examples
which make use of OpenGamma classes. However, we might also want to pull in
extra information about those classes, such as Javadoc comments or the actual
source code of the methods.

In this section, we will look at how to pull that information in to a document.

In the next section, we will go through writing an extensive example in Java
and also writing up documentation for the example, including pulling in the
source code, the results, and documentation for the classes we reference.

The json-doclet project is part of Dexy, and it lets us run a custom Javadoc
\href{http://download.oracle.com/javase/6/docs/technotes/guides/javadoc/doclet/overview.html}{Doclet}
which gathers all the Javadoc information plus extracts source code, and
writes all this information to a JSON file.

Within our Dexy documents, we can pull information out of this JSON dict. A
special Dexy filter adds some nice features like syntax highlighting the Java
source code stored in the dict. You can view the filter reference documentation
for the \href{http://dexy.it/docs/filters/javadoc}{javadoc filter}.

%%% @export "assign-class-to-local-variable"
<% set cn_class = d['/javadoc-data.json|javadocs']['packages']['com.opengamma.math.number']['classes']['ComplexNumber'] %>
%%% @end

When working with a class, it can be useful to assign that branch of the dict to a local variable:

\fvset{fontsize=\scriptsize}
<< d['writing-docs.tex|idio|l']['assign-class-to-local-variable'] >>
\fvset{fontsize=\small}

Then we can access class comment text via:

<< d['writing-docs.tex|idio|l']['class-comment-text'] >>

Here is the comment for this class:

%%% @export "class-comment-text"
<< cn_class['comment-text'] >>
%%% @end

We can iterate over methods in the class docs via:

<< d['writing-docs.tex|idio|l']['print-methods'] >>

Documentation is available for the following methods:

%%% @export "print-methods"
\begin{itemize}
<% for name in cn_class['methods'].keys() -%>
\item{<< name >>}
<% endfor -%>
\end{itemize}
%%% @end

We can iterate over constructors in the class docs via:

<< d['writing-docs.tex|idio|l']['print-methods'] >>

Documentation is available for the following constructors:

%%% @export "print-constructors"
\begin{itemize}
<% for name in cn_class['constructors'].keys() -%>
\item{<< name >>}
<% endfor -%>
\end{itemize}
%%% @end

In the previous section, we used the following constructor:

<< cn_class['constructors']['ComplexNumber(double,double)']['source-latex'] >>

If we didn't have an imagniary component, we could have used an alternate constructor:

\begin{Verbatim}
<< cn_class['constructors']['ComplexNumber(double)']['comment-text'] >>
\end{Verbatim}
<< cn_class['constructors']['ComplexNumber(double)']['source-latex'] >>

Here is the source of the \verb|toString()| method:

<< cn_class['methods']['toString()']['source-latex'] >>

\section{A Real Example}

In this section we discuss writing the SABR extrapolation example. The example
is adapted from a unit test.

<% set sabr_class = d['/javadoc-data.json|javadocs']['packages']['com.opengamma.financial.model.option.pricing.analytic.formula']['classes']['SABRExtrapolationRightFunction'] %>

First we look at some of the docs and source of the classes we will use in our
example.

\subsection{SABRExtrapolationRightFunction Class}

<< sabr_class['comment-text'] >>

We will want to create an instance of this function. Here is the constructor:

\fvset{fontsize=\footnotesize}
<< sabr_class['constructors']['SABRExtrapolationRightFunction(double,SABRFormulaData,double,double,double)']['source-latex'] >>
\fvset{fontsize=\small}

Then we will use the \verb|price| function.

<< sabr_class['methods']['price(EuropeanVanillaOption)']['comment-text'] >>
\fvset{fontsize=\footnotesize}
<< sabr_class['methods']['price(EuropeanVanillaOption)']['source-latex'] >>
\fvset{fontsize=\small}

\subsection{SABRFormulaData}

The other class we use is SABRFormulaData.

<% set sabr_formula_data_class = d['/javadoc-data.json|javadocs']['packages']['com.opengamma.financial.model.volatility.smile.function']['classes']['SABRFormulaData'] %>

<< sabr_formula_data_class['constructors']['SABRFormulaData(double,double,double,double)']['source-latex'] >>

\subsection{Example}

Here are our imports:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['imports'] >>

And the class definition:

<< d['sabr-extrapolation/SabrExtrapolationExample.java|idio|l']['class-def'] >>


