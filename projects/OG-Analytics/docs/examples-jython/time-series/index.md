# Introduction to Time Series Classes

## Class List

{% set datetime_info = [
  [
	"javax.time.calendar.LocalDate",
	"com.opengamma.util.timeseries.localdate",
	"1 Day",
	"ArrayLocalDateDoubleTimeSeries",
	"ListLocalDateDoubleTimeSeries",
	"MapLocalDateDoubleTimeSeries"
  ],
  [
	"java.util.Date",
	"com.opengamma.util.timeseries.date",
	"1 Day",
	"ArrayDateDoubleTimeSeries",
	"ListDateDoubleTimeSeries",
	"MapDateDoubleTimeSeries"
  ],
  [
	"java.sql.Date",
	"com.opengamma.util.timeseries.sqldate",
	"1 Day",
	"ArraySQLDateDoubleTimeSeries",
	"ListSQLDateDoubleTimeSeries",
	"MapSQLDateDoubleTimeSeries"
  ],
  [
	"javax.time.calendar.ZonedDateTime",
	"com.opengamma.util.timeseries.zoneddatetime",
	"1 millisecond",
	"ArrayZonedDateTimeDoubleTimeSeries",
	"ListZonedDateTimeDoubleTimeSeries",
	"MapZonedDateTimeDoubleTimeSeries"
  ],
  [
	"java.util.Date",
	"com.opengamma.util.timeseries.datetime",
	"1 millisecond",
	"ArrayDateTimeDoubleTimeSeries",
	"ListDateTimeDoubleTimeSeries",
	"MapDateTimeDoubleTimeSeries"
  ],
  [
	"java.lang.Double",
	"com.opengamma.util.timeseries.yearoffset",
	"variable, but << 1 microsecond",
	"ArrayYearOffsetDoubleTimeSeries",
	"ListYearOffsetDoubleTimeSeries",
	"MapYearOffsetDoubleTimeSeries"
  ]
] %}

<table>
<tr><th>Java Date Type</th><th>OG Package</th><th>Accuracy</th><th>Array Storage</th><th>List Storage</th><th>Map Storage</th></tr>
{% for jdpn, ogpn, dur, array_cls, list_cls, map_cls in datetime_info %}
<tr>
  <td>{{ jdpn }}</td>
  <td>{{ ogpn }}</td>
  <td>{{ dur }}</td>
  <td><a href="/{{ OG_VERSION }}/java/javadocs/{{ ogpn.replace(".", "/") }}/{{ array_cls }}.html">{{ array_cls }}</a></td>
  <td><a href="/{{ OG_VERSION }}/java/javadocs/{{ ogpn.replace(".", "/") }}/{{ list_cls }}.html">{{ list_cls }}</a></td>
  <td><a href="/{{ OG_VERSION }}/java/javadocs/{{ ogpn.replace(".", "/") }}/{{ map_cls }}.html">{{ map_cls }}</a></td>
{% endfor %}
</table>


## Quick Start - Jython

{{ d['time-series.py|fn|idio|jythoni|pyg']['local-date-imports'] }}

To build up a time series of local dates:

{{ d['time-series.py|fn|idio|jythoni|pyg']['build-ts-up'] }}

To create a time series from an existing time series:

{{ d['time-series.py|fn|idio|jythoni|pyg']['ts-from-existing'] }}

Or an array:

{{ d['time-series.py|fn|idio|jythoni|pyg']['ts-from-arrays'] }}

## Quick Start - Java

{{ d['/examples/time-series/TimeSeriesExample.java|pyg'] }}

Here is output generated by running this Java example:

<pre>
{{ d['/examples/time-series/TimeSeriesExample.java|fn|java'] }}
</pre>

## Guide

### Types of Value

The time series library splits into two primary classes of time series

Object time series - generic classes with efficient storage of the date/time of each data point, and an object reference for each value
Double time series - specifically designed to store double-precision floating point values as native types (as opposed to Double objects)

Both of these hierarchies implement the TimeSeries<DATE_TYPE, VALUE_TYPE> interface.

### Date Formats

For each type of type series there are a separate set of classes availble to support different underlying date formats.  The approach of the library is to always store date/times as either primitive integers (for dates) or longs (date/times), and to convert to/from richer types on the fly as necessary.  The underlying representations are referred to as FastTimeSeries and FastObjectTimeSeries and can directly, although their operation is totally transparent, and there are few reasons to access the primitive values.  The formats available for date (with one day resolution) encoding are:

DateTimeSeries (a java.util.Date to day resolution)
SQLDateTimeSeries (a java.sql.Date)
LocalDateTimeSeries (a JSR-310 LocalDate)

and for date/times (stored generally as 64-bit milliseconds since the epoch (1/1/1970)):

DateTimeTimeSeries (a java.util.Date to full resolution)
ZonedDateTimeTimeSeries (a JSR-310 ZonedDateTime)
DateOffsetTimeSeries (a special class where the date is represented as a double-precision floating point value for the number of years from a fixed date - this makes it extremely easy to perform certain cash-flow analytics)

### Storage Data Structure Choices

Just to make life more complicated there is a choice of how the series is stored:

A primitive array - these series are immutable
Use this when you have a fixed data set ready

A list - existing implementations use a high speed primitive arraylist implementation
Use this when you're building up a series in date order
This implements one of the Mutable*TimeSeries interfaces and can have items removed, added, etc.

A map, existing implementations use a high speed optimized map for primatives
Use this when you're creating non-linear distributions of data points as you go
This implements one of the Mutable*TimeSeries interfaces and can have items removed, added, etc.

### Conversions

All time series implementations have an almost exhaustive range of conversion methods to convert from one representation to another.  For example you could create a time series based on a java.sql.Date and convert it easily to a JSR-310 LocalDate series with no additional code.  Just use the .to*TimeSeries methods.  The only option not available is to convert to a series backed by a map directly, the methods only support conversion to a 'Mutable' time series of a particular type, which is always backed by a list.

### Operations

All operators are simply methods on the time series object.  Unary operators return objects of the same type as the operand (the object in question!).

{{ d['time-series.py|fn|idio|jythoni|pyg']['unary-ops'] }}

Time Series Ops

{{ d['time-series.py|fn|idio|jythoni|pyg']['sub-series'] }}

Summaries - returns aggregates or summaries of the values in the series

{{ d['time-series.py|fn|idio|jythoni|pyg']['summaries'] }}
{{ d['time-series.py|fn|idio|jythoni|pyg']['info'] }}

Binary operators return objects of the type of the object being invoked (the left hand side).  Operators will generally perform any necessary conversions internally to allow any reasonable series to be passed as a parameter.

There are three types of binary operator:

#### Scalar

Each element in the source series is operated on by the same scalar value.

{{ d['time-series.py|fn|idio|jythoni|pyg']['binary-ops-scalar'] }}

#### Standard

Takes the intersection of the dates in both series to populate the resultant time series.

{{ d['time-series.py|fn|idio|jythoni|pyg']['binary-ops'] }}

#### Union

Takes the union of the dates, and simply copies dates that are only in one series.

{{ d['time-series.py|fn|idio|jythoni|pyg']['union'] }}


### Methods

{{ d['time-series.py|fn|idio|jythoni|pyg']['methods-list'] }}


