title: Adding support for a new custom Security
shortcut: DOC:Adding support for a new custom Security
---
The security representations in the system are defined in a two-tier hierarchy. The first level contains top-level asset classes such as equities, futures, and options. The second level contains specific refinements of these asset classes with additional specific fields. For example, a swaption is a second level refinement of the top level option.

Adding a custom asset class, so that it can be supported by the OpenGamma supplied Security Master, consists in summary of:


#  Creating a `.proto <http://www.fudgemsg.org/display/FDG/Fudge+Proto>`_  definition of the data needed to model the asset


#  Extending the Java visitor patterns to process the new class


#  Extending the automatic test cases to verify the Security Master behaviour


#  Extending the hibernate database so the Security Master can work with the new class


..............................
Adding a top-level asset class
..............................


~~~~~~~~~~~~~~~~~~~~~~~~~~
Creating the `.proto` file
~~~~~~~~~~~~~~~~~~~~~~~~~~


The use of Fudge Proto is generally being replaced with hand-written builders, but are still used in parts of the system.  They also make it easier to port builders to non-Java architectures, so for the time being, we're continuing to maintain them.  They are however optional on your own securities.


All of the top-level asset classes extend from `com.opengamma.financial.security.FinancialSecurity` defined by `FinancialSecurity.proto`. We will use a package `com.opengamma.example` and `ExampleSecurity`, so begin by creating `com/opengamma/example/ExampleSecurity.proto` \- the minimum declaration would be:



::

    namespace com.opengamma.example {
    
      message ExampleSecurity extends com.opengamma.financial.security.FinancialSecurity {
    
        required string securityType [default="EXAMPLE"];
    
        // ... fields necessary to define the asset class
    
        binding Java {
          body <<<JAVA
            public <T> T accept(ExampleSecurityVisitor<T> visitor) { return visitor.visitExampleSecurity(this); }
            public <T> T accept(com.opengamma.financial.security.FinancialSecurityVisitor<T> visitor) { return visitor.visitExampleSecurity(this); }
    JAVA;
        }
    
      }
    
    }




The `securityType` field is defined in the `com.opengamma.master.security.ManageableSecurity` class that all OpenGamma supplied asset classes extend from. This is a common field that allows aggregation of assets by class for example. After the security type definition, any data needed to describe an instance of the asset should be defined. Refer to files such as `SwapSecurity.proto` or `OptionSecurity.proto` in the OG-Financial package for more complete examples, or the `Fudge Proto specification <http://www.fudgemsg.org/display/FDG/Fudge+Proto>`_  for more information. The `OptionSecurity.proto` definition is an example of an abstract top-level asset class.

The `.proto` definition defines a data format for the asset allowing a representation to be easily passed across a network and stored in caches from which a Java (or possibly C# or C++) representation can be generated. The `binding Java ...` fragment allows code specific to the Java representation to be inserted - in this case using a visitor pattern for processing instances of the asset.

~~~~~~~~~
JodaBeans
~~~~~~~~~


We are now not generating builder code from .proto files, and they remain more as documentation than anything else.  We now make heavy use of the `JodaBean <http://joda-beans.sourceforge.net/>`_  meta-data object system.  This allows you to decorate fields with annotations that indicate which you be exposed as properties (and also can enforce constraints regarding e.g. null-ness).  Extra methods for accessors, equals, hashCode, etc are then auto-generated by running the `ant joda-bean` task.  Property sets can then be iterated over and introspected at runtime without resort to reflection, which allows the use of a JodaBean fudge builder in some cases.  In many cases though, we still prefer to use a builder pattern.  These builder classes (typically named XXXFudgeBulder) are registered with a global OpenGammaFudgeContext that scans the classpath for classes with an @FudgeBuilderFor(ClassName.class) annotation.  These are then available across the platform.  Note that for Excel development, the scan process is switched off by default and cache files are used, to speed up loading of the `OpenGamma Tools for Microsoft Excel </confluence/DOC/OpenGamma-Platform-Documentation/OpenGamma-Tools-for-Microsoft-Excel/index.rst>`_ .

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Extending the visitor interfaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The `ExampleSecurityVisitor` interface should first be defined. In the abstract case of `OptionSecurity` this will only list the sub-classes, in this example or in instantiable cases such as `SwapSecurity` it will include a method for the top-level asset class:



.. code::

    package com.opengamma.example;
    
    public interface ExampleSecurityVisitor<T> {
    
      T visitExampleSecurity(ExampleSecurity security);
    
    }




This should resolve one of the errors introduced by the new `ExampleSecurity.java` file.

All of the top-level asset classes that extend `FinancialSecurity` can be processed by `FinancialSecurityVisitor`. This must be extended to include a dispatch method for the new asset class, for example:



.. code::

    package com.opengamma.financial.security;
    
    public interface FinancialSecurityVisitor<T> {
    
      // ... existing visit methods
    
      T visitExampleSecurity(ExampleSecurity security);
    
    }




This should resolve the other error introduced by `ExampleSecurity.java` but will then report a small number of additional errors for any classes that directly implement the `FinancialSecurityVisitor` interface and now must be addressed so that they can handle the new asset class (or throw an exception if they cannot). This will include:


*  `AssetClassAggregationFunction.java` \- implement to return an appropriate string (or `"UNKNOWN"`), referring to the existing asset class methods for examples


*  `FinancialSecurityUtils.java` \- implement to return the currency of the asset class or `null` if no currency is appropriate, referring to the existing asset class methods for examples


The `FinancialSecurityVisitorAdapter` class will require extending, for example:



.. code::

    package com.opengamma.financial.security;
    
    // ... imports
    
    public class FinancialSecurityVisitorAdapter<T> implements FinancialSecurityVisitor<T> {
    
      // ... sub-class visitors
    
      private final ExampleSecurityVisitor<T> _exampleSecurityVisitor;
    
      public static final class Builder<T> {
    
        // ... sub-class visitors
    
        private ExampleSecurityVisitor<T> _exampleSecurityVisitor;
    
        // ... sub-class visitor setting methods
    
        public Builder<T> exampleSecurityVisitor<T>(final ExampleSecurityVisitor<T> exampleSecurityVisitor) {
          _exampleSecurityVisitor = exampleSecurityVisitor;
          return this;
        }
    
      }
    
      public FinancialSecurityVisitorAdapter(/* ... sub-class visitors, */ ExampleSecurityVisitor<T> exampleSecurityVisitor) {
        // ... assignment to sub-class visitors
        _exampleSecurityVisitor = exampleSecurityVisitor;
      }
    
      public FinancialSecurityVisitorAdapter() {
        this(/* ... null parameters to other sub-class visitors, */ null);
      }
    
      protected FinancialSecurityVisitorAdapter(final Builder<T> builder) {
        this(/* ... sub-class visitors from builder, */ builder._exampleSecurityVisitor);
      }
    
      // ... methods from FinancialSecurityVisitor
    
      @Override
      public T visitExampleSecurity(final ExampleSecurity security) {
        return (_exampleSecurityVisitor != null) ? security.accept (_exampleSecurityVisitor) : null;
      }
    
    }




This will highlight a further error with `DetailedAssetClassAggregationFunction` to be resolved to return an appropriate string to describe the new asset class, for example:



.. code::

    package com.opengamma.financial.aggregation;
    
    // ... imports
    
    public class DetailedAssetClassAggregationFunction implements AggregationFunction<String> {
    
      // ... asset classes
      /* package */static final String EXAMPLE = "Example";
    
      @Override
      public String classifyPosition(final Position position) {
        final Security security = position.getSecurity();
        if (security instanceof FinancialSecurity) {
          FinancialSecurity finSec = (FinancialSecurity) security;
          return finSec.accept(new FinancialSecurityVisitorAdapter<String>(
    
            // ... asset sub-class visitors,
    
            new ExampleSecurityVisitor<String>() {
              @Override
              public String visitExampleSecurity(final ExampleSecurity security) {
                return EXAMPLE;
              }
            }
    
          ));
        } else {
          return UNKNOWN;
        }
      }
    
    }




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Extending the automated test cases
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


All of the asset classes supported by the OpenGamma supplied Security Master are listed in `com.opengamma.masterdb.security.SecurityTestCaseMethods`. Extend this to include the new asset class:



.. code::

    package com.opengamma.masterdb.security;
    
    public interface SecurityTestCaseMethods {
    
      // ... test other asset classes
    
      void testExampleSecurity();
    
    }




This will highlight errors in the test cases that now need to be extended to handle the new asset class:



.. code::

    package com.opengamma.masterdb.security;
    
    // ... imports
    
    public class DbSecurityMasterRandomTest extends DBTest implements SecurityTestCaseMethods {
    
      // ... test other asset classes
    
      @Override
      @Test
      public void testExampleSecurity() {
        _testCase.testExampleSecurity();
      }
    
    }






.. code::

    package com.opengamma.masterdb.security;
    
    // ... imports
    
    public abstract class SecurityTestCase implements SecurityTestCaseMethods {
    
      // ... test other asset classes
    
      @Override
      @Test
      public void testExampleSecurity() {
        assertSecurities(ExampleSecurity.class);
      }
    
    }




The supplied test harness should be sufficient for any classes that contain standard primitive values (e.g. doubles, strings, integers, dates) or values already used by the OpenGamma supplied asset classes (e.g. `BusinessDayConvention`). If any other complex or composite types are used as part of the asset, the test harness may require extending with knowledge of this type to allow it to construct asset instances with which to test the database. Refer to the documentation of `SecurityTestCase` for more information.

The tests on OG-MasterDB should now compile and run, however the `DbSecurityMasterRandomTest` will fail as the database does not yet know how to handle the new asset class. When this test passes, the next and final step to extend the Security Master will be complete.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Extending the OpenGamma Security Master
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The data storage model defines a hibernate database table for each top-level asset class that extends from `SecurityBean.hbm.xml`. The table for an asset type contains the union of any sub-classes defined on that asset type. There are additional tables defined for common concepts such as business day conventions, currencies and identifier relationships. Refer to `OptionSecurityBean.hbm.xml` for a full example, which uses a single table to describe all of the options supported. OpenGamma supplied Security Master tables are all prefixed with `sec_` to allow them to be held in the same database system as other components without risk of collision.

To add the example asset class to a hibernate scheme, first create the necessary bean to mirror the asset definition and a hibernate mapping file. Note that any non-primitive types (for example a currency) should be held as the 'bean' representation (for example CurrencyBean). Refer to the source code of one of the supplied asset types for a complete example.



.. code::

    package com.opengamma.example.hibernate;
    
    import com.opengamma.masterdb.security.hibernate.SecurityBean;
    
    public class ExampleSecurityBean extends SecurityBean {
      // ... fields with accessors and mutators to match the elements from ExampleSecurity
    }






.. code::

    <?xml version="1.0"?>
    <!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
      "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    <hibernate-mapping package="com.opengamma.example.hibernate">
      <union-subclass name="ExampleSecurityBean" extends="com.opengamma.masterdb.security.hibernate.SecurityBean" table="sec_example">
        <!-- mapping of properties from the ExampleSecurityBean class to database fields -->
      </union-subclass>
      <query name="ExampleSecurityBean.one.bySecurityId"><![CDATA[
        from
          ExampleSecurityBean as e
        where
          e.securityId = :securityId
      ]]></query>
    </hibernate-mapping>




A matching table in the underlying database (in this example `sec_example`) must be created to hold the data in the format described by the mapping file.

To convert between the hibernate mapped bean and a usable representation of the asset instance, an 'operation' class must be provided. For example:



.. code::

    package com.opengamma.example.hibernate;
    
    // ... imports
    
    public class ExampleSecurityBeanOperation extends AbstractSecurityBeanOperation<ExampleSecurity, ExampleSecurityBean> {
    
      public static final ExampleSecurityBeanOperation INSTANCE = new ExampleSecurityBeanOperation();
    
      private ExampleSecurityBeanOperation() {
        super("EXAMPLE", ExampleSecurity.class, ExampleSecurityBean.class);
      }
    
      @Override
      public ExampleSecurityBean createBean(final OperationContext context, final HibernateSecurityMasterDao secMasterSession, final ExampleSecurity security) {
        // ... create and return an instance of ExampleSecurityBean that represents the security
      }
    
      @Override
      public ExampleSecurity createSecurity(final OperationContext context, final ExampleSecurityBean bean) {
        // ... create an return an instance of ExampleSecurity that contains the information described in the bean
      }
    
    }




For a more thorough example of a top-level asset class that supports sub-classes, refer to the source code for `OptionSecurityBeanOperation` or `SwapSecurityBeanOperation`. These use the visitor patterns to execute the correct behaviour for the sub-class involved.

The bean operation class must then be registered with the Security Master by updating `HibernateSecurityMasterDetailProvider` and `HibernateSecurityMasterFiles`, for example:



.. code::

    package com.opengamma.masterdb.security.hibernate;
    
    // ... imports
    
    public class HibernateSecurityMasterDetailProvider implements SecurityMasterDetailProvider {
    
      // ...
    
      static {
        // ... loadBeanOperation calls
        loadBeanOperation(ExampleSecurityBeanOperation.INSTANCE);
      }
    
    }






.. code::

    package com.opengamma.masterdb.security.hibernate;
    
    // ... imports
    
    public final class HibernateSecurityMasterFiles implements HibernateMappingFiles {
    
      @Override
      public Class<?>[] getHibernateMappingFiles() {
        return new Class<?>[] {
          // ... other bean classes,
          ExampleSecurityBean.class
        };
      }
    
    }




Repeating the OG-MasterDB tests will now confirm that the asset can be converted to/from the bean representation, and that the bean can be persisted in the hibernate database correctly. When this test passes, the new asset class is ready for use.

....................................................
Adding a custom variation of an existing asset class
....................................................


~~~~~~~~~~~~~~~~~~~~~~~~~~
Creating the `.proto` file
~~~~~~~~~~~~~~~~~~~~~~~~~~


An extension to an existing asset class will extend from that asset class. We will create a new type of option within the `com.opengamma.security.option` package called `ExampleOptionSecurity`. For example:



::

    namespace com.opengamma.financial.security.option {
    
      message ExampleOptionSecurity extends OptionSecurity {
    
        required string securityType [default = "EXAMPLE_OPTION"];
    
        // ... additional fields to defined the asset class
    
        binding Java {
          body "public <T> T accept (OptionSecurityVisitor<T> visitor) { return visitor.visitExampleOptionSecurity (this); }";
        }
    
      }
    
    }




The `securityType` field is defined in the `com.opengamma.master.security.ManageableSecurity` class that all OpenGamma supplied asset classes extend from. This is a common field that allows aggregation of assets by class for example. After the security type definition, any data needed to describe an instance of the asset should be defined. Refer to files such as `Swaption.proto` or `EquityOptionSecurity.proto` in the OG-Financial package for more complete examples, or the `Fudge Proto specification <http://www.fudgemsg.org/display/FDG/Fudge+Proto>`_  for more information.

The `.proto` definition defines a data format for the asset allowing a representation to be easily passed across a network and stored in caches from which a Java (or possibly C# or C+\+ representation) can be generated. The `binding Java ...` fragment allows code specific to the Java representation to be inserted - in this case using a visitor pattern for processing instances of the asset.

From a command line, the `.proto` files must be compiled with `ant fudge-proto` if using the OpenGamma build system, or direct use of the code generator (see http://www.fudgemsg.org/display/FDG/Java+Proto+Implementation). This will create `com/opengamma/financial/security/option/ExampleOptionSecurity.java`. Note that the generated Java file will not compile at this point as it is referring to a non-existent method `visitExampleOptionSecurity` on the `OptionSecurityVisitor` interface.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Extending the visitor interface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The `OptionSecurityVisitor` interface should be extended to include a dispatch method for the new sub-class. For example:



.. code::

    package com.opengamma.financial.security.option;
    
    public interface OptionSecurityVisitor<T> {
    
      // ... existing visit methods
    
      T visitExampleOptionSecurity(ExampleOptionSecurity security);
    
    }




This should resolve the error in `ExampleOptionSecurity.java` but will then report a small number of additional errors for any classes that implement this interface and must now be addressed so that they can handle the new asset class (or throw an exception if they cannot). This will include:


*  `DetailedAssetClassAggregationFunction` \- implement to return an appropriate string (or `"UNKNOWN"`), referring to the existing asset class methods for examples


*  Analytic function wrappers, in this case `OptionGreekToValueGreekConverterFunction`


*  Security Master classes from OG-MasterDB - discussed later


Any function definitions that make use of the updated visitor interface must be updated to handle the new asset type so that values produced are correct and appropriate by implementing the additional method in the visitor. If the function is unable to produce a suitable value for the new sub-class of asset its `canApplyTo` should be updated so that it will not be used for instances of that class and a method may be added to satisfy the Java compiler that throws an `UnsupportedOperationException`. Refer to `Adding a new Function Definition and Invoker </confluence/DOC/OpenGamma-Platform-Documentation/Developing-Applications-to-Integrate-with-the-OpenGamma-Platform/Adding-a-new-Function-Definition-and-Invoker/index.rst>`_  for more information about the function definition classes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Extending the automatic test cases
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


All of the asset classes supported by the OpenGamma supplied Security Master are listed in `com.opengamma.masterdb.security.SecurityTestCaseMethods`. Extend this to include the new asset class:



.. code::

    package com.opengamma.masterdb.security;
    
    public interface SecurityTestCaseMethods {
    
      // ... test other asset classes
    
      void testExampleOptionSecurity();
    
    }




This will highlight errors in the test cases that now need to be extended to handle the new asset class:



.. code::

    package com.opengamma.masterdb.security;
    
    // ... imports
    
    public class DbSecurityMasterRandomTest extends DBTest implements SecurityTestCaseMethods {
    
      // ... test other asset classes
    
      @Override
      @Test
      public void testExampleOptionSecurity() {
        _testCase.testExampleOptionSecurity();
      }
    
    }






.. code::

    package com.opengamma.masterdb.security;
    
    // ... imports
    
    public abstract class SecurityTestCase implements SecurityTestCaseMethods {
    
      // ... test other asset classes
    
      @Override
      @Test
      public void testExampleOptionSecurity() {
        assertSecurities(ExampleOptionSecurity.class);
      }
    
    }




The supplied test harness should be sufficient for any classes that contain standard primitive values (e.g. doubles, strings, integers, dates) or values already used by the OpenGamma supplied asset classes (e.g. `BusinessDayConvention`). If any other complex or composite types are used as part of the asset, the test harness may require extending with knowledge of this type to allow it to construct asset instances with which to test the database. Refer to the documentation of `SecurityTestCase` for more information.

The tests on OG-MasterDB should now compile without error; however, the hibernate database classes in OG-MasterDB still have an error resulting from the earlier extension to the visitor interface.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Extending the OpenGamma Security Master
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The data storage model holds each top-level asset class in a table that contains the union of all of the sub-class properties. If the new asset sub-class does not have any additional properties the data model does not need updating. Otherwise, the bean that is mapped to the underlying database must include the additional fields. Note that in some instances it may be possible or desirable to reuse an existing field in the bean (and database table) that represents a similar concept in one of the other sub-classes of the asset.

When adding properties to the bean, the hibernate mapping file (and underlying database field) must not include a `not-null` constraint as the property may need to be `null` for other sub-classes of the top-level asset.

Once the bean is capable of holding any additional data, the mapping from the bean to/from the asset representation must be updated. The existing mappings make use of the visitor interface extended earlier. For example:



.. code::

    package com.opengamma.masterdb.security.hibernate.option;
    
    // ... imports
    
    public final class OptionSecurityBeanOperation extends AbstractSecurityBeanOperation<OptionSecurity, OptionSecurityBean> {
    
      // ... constructor
    
      @Override
      public OptionSecurity createSecurity(final OperationContext context, final OptionSecurityBean bean) {
        // ... construct the exercise type from the bean representation
        // ... construct the pay off style from the bean representation
        OptionSecurity sec = bean.getOptionSecurityType().accept(new OptionSecurityVisitor<OptionSecurity>() {
    
          // ... construct other option types
    
          @Override
          public OptionSecurity visitExampleOptionSecurity(ExampleOptionSecurity security) {
            return new ExampleOptionSecurity(exerciseType, payoffStyle, bean.getOptionType(), bean.getStrike(),
                                             expiryBeanToExpiry(bean.getExpiry()),
                                             identifierBeanToIdentifier(bean.getUnderlying()),
                                             currencyBeanToCurrency(bean.getCurrency()));
          }
        });
        return sec;
      }
    
      @Override
      public OptionSecurityBean createBean(final OperationContext context, final HibernateSecurityMasterDao secMasterSession, final OptionSecurity security) {
        return security.accept(new OptionSecurityVisitor<OptionSecurityBean>() {
    
          private OptionSecurityBean createSecurityBean(final OptionSecurity security) {
            // ... create a bean representation of the top-level asset data
          }
    
          // ... handle other option types
    
          @Override
          public OptionSecurityBean visitExampleOptionSecurity(ExampleOptionSecurity security) {
            final OptionSecurityBean bean = createSecurityBean(security);
            // ... set any additional bean properties from the sub-class
            return bean;
          }
    
        });
      }
    
    }




A 'type' field within the bean holds an enum that indicates which sub-class is represented - this must be extended to include the new class. This involves two classes - one is a Java enum (in this example `OptionSecurityType`) and the other is a hibernate mapping for it (in this example `OptionSecurityTypeUserType`). These also refer to the modified visitor interface so must be updated:



.. code::

    package com.opengamma.masterdb.security.hibernate.option;
    
    // ... imports
    
    public enum OptionSecurityType {
    
      // ... existing option types,
      EXAMPLE;
    
      public static OptionSecurityType identify(OptionSecurity object) {
        return object.accept(new OptionSecurityVisitor<OptionSecurityType>() {
    
          // .. recognise other option types
    
          @Override
          public OptionSecurityType visitExampleOptionSecurity(ExampleOptionSecurity security) {
            return EXAMPLE;
          }
    
        });
      }
    
      public <T> T accept(final OptionSecurityVisitor<T> visitor) {
        switch (this) {
          // ... other option types
          case EXAMPLE:
            return visitor.visitExampleOptionSecurity(null);
        }
      }
    
    }






.. code::

    package com.opengamma.masterdb.security.hibernate.option;
    
    // ... imports
    
    public class OptionSecurityTypeUserType extends EnumUserType<OptionSecurityType> {
    
      // ... values held in the database to indicate option type
      private static final String EXAMPLE = "Example";
    
      @Override
      protected String enumToStringNoCache(OptionSecurityType value) {
        return value.accept(new OptionSecurityVisitor<String>() {
    
          // ... handle other option types
    
          @Override
          public String visitExampleOptionSecurity(ExampleOptionSecurity security) {
            return EXAMPLE;
          }
    
        });
      }
    
    }




Everything should now compile and repeating the OG-MasterDB tests will now confirm that the asset can be converted to/from the bean representation, and that the bean can be persisted in the hibernate database correctly. When the OG-MasterDB tests pass, the new asset class is ready for use.
